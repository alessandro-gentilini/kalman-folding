#+TITLE: Kalman Folding 9: in C (WORKING DRAFT)
#+SUBTITLE: Extracting Models from Data, One Observation at a Time
#+AUTHOR: Brian Beckman
#+DATE: <2016-05-17 Tue>
#+EMAIL: bbeckman@34363bc84acc.ant.amazon.com
#+OPTIONS: ':t *:t -:t ::t <:t H:3 \n:nil ^:t arch:headline author:t c:nil
#+OPTIONS: creator:comment d:(not "LOGBOOK") date:t e:t email:nil f:t inline:t
#+OPTIONS: num:t p:nil pri:nil stat:t tags:t tasks:t tex:t timestamp:t toc:t
#+OPTIONS: todo:t |:t
#+SELECT_TAGS: export
#+STARTUP: indent
#+LaTeX_CLASS_OPTIONS: [10pt,oneside,x11names]
#+LaTeX_HEADER: \usepackage{geometry}
#+LaTeX_HEADER: \usepackage{amsmath}
#+LaTeX_HEADER: \usepackage{amssymb}
#+LaTeX_HEADER: \usepackage{amsfonts}
#+LaTeX_HEADER: \usepackage{palatino}
#+LaTeX_HEADER: \usepackage{siunitx}
#+LaTeX_HEADER: \usepackage{esdiff}
#+LaTeX_HEADER: \usepackage{xfrac}
#+LaTeX_HEADER: \usepackage{nicefrac}
#+LaTeX_HEADER: \usepackage{faktor}
#+LaTeX_HEADER: \usepackage[euler-digits,euler-hat-accent]{eulervm}
#+OPTIONS: toc:2

* COMMENT Preliminaries

This section is just about setting up org-mode. It shouldn't export to the
typeset PDF and HTML.

#+BEGIN_SRC emacs-lisp :exports :results none
  (defun update-equation-tag ()
    (interactive)
    (save-excursion
      (goto-char (point-min))
      (let ((count 1))
        (while (re-search-forward "\\tag{\\([0-9]+\\)}" nil t)
          (replace-match (format "%d" count) nil nil nil 1)
          (setq count (1+ count))))))
  (update-equation-tag)
  (setq org-confirm-babel-evaluate nil)
  ; (org-babel-map-src-blocks nil (org-babel-remove-result))
  ; (slime)
#+END_SRC

* Abstract

In this literate program, we show one way to implement the basic Kalman fold in
C. The background for Kalman folding appears in /Kalman Folding, Part
1/,[fn:klf1] where we highlight the the unique advantages of functional folding
for deploying test-hardened code verbatim in harsh, mission-critical
environments. In that and in other papers in this series, the emphasis is on
mathematical clarity and conciseness. Here, the emphasis is on embedded systems
and on the primary language for implementing such systems, C.

#+BEGIN_COMMENT
Here, we prototype a couple of less friendly environments and demonstrate
exactly the same Kalman accumulator function at work. These less friendly
environments are
- lazy streams, where new observations are computed on demand but never fully
  realized in memory, thus not available for inspection in a debugger
- asynchronous observables, where new observations are delivered at arbitrary
  times from an external source, thus not available for replay once consumed by
  the filter

Streams are a natural fit for integration of differential equations, which often
arise in applications. As such, they enable unique modularization for all kinds
of filters, including non-linear Extended Kalman Filters.

The fact that the Kalman accumulator function gives bit-for-bit identical
results in all cases gives us high confidence that code developed in friendly
environments will behave as intended in unfriendly environments. This level of
repeatability is available /only/ because of functional decomposition, which
minimizes the coupling between the accumulator function and the environment and
makes it possible to deploy exactly the same code, without even recompilation,
in all environments.
#+END_COMMENT

* COMMENT Kalman Folding in the Wolfram Language

In this series of papers, we use the Wolfram language[fn:wolf] because it excels
at concise expression of mathematical code. All examples in these papers can be
directly transcribed to any modern mainstream language that supports closures.
For example, it is easy to write them in C++11 and beyond, Python, any modern
Lisp, not to mention Haskell, Scala, Erlang, and OCaml. Many can be written
without full closures; function pointers will suffice, so they are easy to write
in C. It's also not difficult to add extra arguments to simulate just enough
closure-like support in C to write the rest of the examples in that language.


In /Kalman Folding/,[fn:klfl] we found the following elegant formulation for the
accumulator function of a fold that implements the static Kalman filter:

#+BEGIN_LaTeX
\begin{equation}
\label{eqn:kalman-cume-definition}
\text{kalmanStatic}
\left(
\mathbold{Z}
\right)
\left(
\left\{
\mathbold{x},
\mathbold{P}
\right\},
\left\{
\mathbold{A},
\mathbold{z}
\right\}
\right) =
\left\{
\mathbold{x}+
\mathbold{K}\,
\left(
\mathbold{z}-
\mathbold{A}\,
\mathbold{x}
\right),
\mathbold{P}-
\mathbold{K}\,
\mathbold{D}\,
\mathbold{K}^\intercal
\right\}
\end{equation}
#+END_LaTeX

\noindent where

#+BEGIN_LaTeX
\begin{align}
\label{eqn:kalman-gain-definition}
\mathbold{K}
&=
\mathbold{P}\,
\mathbold{A}^\intercal\,
\mathbold{D}^{-1} \\
\label{eqn:kalman-denominator-definition}
\mathbold{D}
&= \mathbold{Z} +
\mathbold{A}\,
\mathbold{P}\,
\mathbold{A}^\intercal
\end{align}
#+END_LaTeX

\noindent and all quantities are matrices:

- $\mathbold{z}$ is a  ${b}\times{1}$ column vector containing one multidimensional observation
- $\mathbold{x}$ is an ${n}\times{1}$ column vector of /model states/
- $\mathbold{Z}$ is a  ${b}\times{b}$ matrix, the covariance of
  observation noise
- $\mathbold{P}$ is an ${n}\times{n}$ matrix, the theoretical
  covariance of $\mathbold{x}$
- $\mathbold{A}$ is a  ${b}\times{n}$ matrix, the /observation partials/
- $\mathbold{D}$ is a  ${b}\times{b}$ matrix, the Kalman denominator
- $\mathbold{K}$ is an ${n}\times{b}$ matrix, the Kalman gain

In physical or engineering applications, these quantities carry physical
dimensions of units of measure in addition to their matrix dimensions as numbers
of rows and columns.
If the physical and matrix dimensions of
$\mathbold{x}$
are
$\left[\left[\mathbold{x}\right]\right]
\stackrel{\text{\tiny def}}{=}
(\mathcal{X}, n\times{1})$
and of
$\mathbold{z}$
are
$\left[\left[\mathbold{z}\right]\right]
\stackrel{\text{\tiny def}}{=}
(\mathcal{Z}, b\times{1})$, then

#+BEGIN_LaTeX
\begin{equation}
\label{eqn:dimensional-breakdown}
\begin{array}{lccccr}
\left[\left[\mathbold{Z}\right]\right]                                       &=& (&\mathcal{Z}^2            & b\times{b}&) \\
\left[\left[\mathbold{A}\right]\right]                                       &=& (&\mathcal{Z}/\mathcal{X}  & b\times{n}&) \\
\left[\left[\mathbold{P}\right]\right]                                       &=& (&\mathcal{X}^2            & n\times{n}&) \\
\left[\left[\mathbold{A}\,\mathbold{P}\,\mathbold{A}^\intercal\right]\right] &=& (&\mathcal{Z}^2            & b\times{b}&) \\
\left[\left[\mathbold{D}\right]\right]                                       &=& (&\mathcal{Z}^2            & b\times{b}&) \\
\left[\left[\mathbold{P}\,\mathbold{A}^\intercal\right]\right]               &=& (&\mathcal{X}\,\mathcal{Z} & n\times{b}&) \\
\left[\left[\mathbold{K}\right]\right]                                       &=& (&\mathcal{X}/\mathcal{Z}  & n\times{b}&)
\end{array}
\end{equation}
#+END_LaTeX

Dimensional arguments, regarding both matrix dimensions and physical dimensions,
are invaluable for checking code and derivations in this topic at-large.

** A Test Example

In the following  example, the observations $\mathbold{z}$ are
$1\times{1}$ matrices, equivalent to scalars, so $b=1$.

The function in equation \ref{eqn:kalman-cume-definition}
/lambda-lifts/[fn:lmlf] $\mathbold{Z}$, meaning that it is necessary to call
/kalmanStatic/ with a constant $\mathbold{Z}$ to get the actual accumulator
function used in folds. This is desirable to reduce coupling between the
accumulator function and its calling environment.

In Wolfram, this function is

#+BEGIN_LaTeX
\begin{verbatim}
kalmanStatic[Zeta_][{x_, P_}, {A_, z_}] :=
 Module[{D, K},
  D = Zeta + A.P.Transpose[A];
  K = P.Transpose[A].Inverse[D];
  {x2 + K.(z - A.x), P - K.D.Transpose[K]}]
\end{verbatim}
#+END_LaTeX

We test it on a small case

#+BEGIN_LaTeX
\begin{verbatim}
Fold[kalmanStatic[IdentityMatrix[1]],
  {ColumnVector[{0, 0, 0, 0}], IdentityMatrix[4]*1000.0},
  {{{{1,  0., 0.,  0.}}, { -2.28442}},
   {{{1,  1., 1.,  1.}}, { -4.83168}},
   {{{1, -1., 1., -1.}}, {-10.46010}},
   {{{1, -2., 4., -8.}}, {  1.40488}},
   {{{1,  2., 4.,  8.}}, {-40.8079}}}
  ] // Chop
~~>
\end{verbatim}
#+END_LaTeX

#+BEGIN_LaTeX
\begin{align}
\label{eqn:kalman-filter-results}
\mathbold{x} &=
\begin{bmatrix}
 -2.97423 \\
  7.2624  \\
 -4.21051 \\
 -4.45378 \\
\end{bmatrix}
\\
\notag
\mathbold{P} &=
\begin{bmatrix}
 0.485458 & 0 & -0.142778 & 0 \\
 0 & 0.901908 & 0 & -0.235882 \\
 -0.142778 & 0 & 0.0714031 & 0 \\
 0 & -0.235882 & 0 & 0.0693839 \\
\end{bmatrix}
\end{align}
#+END_LaTeX

\noindent expecting results within one or two standard deviations of the ground
truth $\aleph=\begin{bmatrix}-3& 9& -4& -5\end{bmatrix}^\intercal$, where the
standard deviations can be found as square roots of the diagonal
elements of $\mathbold{P}$. For details about this test case, see the first
paper in the series, /Kalman Folding, Part 1/.[fn:klfl]

Below, we reproduce these values exactly, to the bit level, by running
/kalmanStatic/ over lazy streams and asynchronous observables.

* COMMENT Concluding Remarks

With prototypes for /foldStream/ and /foldObservable/, we have demonstrated
Kalman folding with exactly the same accumulator function over wildly different
data-delivery environments. This demonstrates the primary thesis of this series
of papers: that writing filters as functional folds enables verbatim deployment
of code in both friendly, synchronous environments with all data in memory, and
unfriendly asynchronous environments using only constant memory. Verbatim means
with no changes at all, not even recompilation.

We have tested these prototypes against bigger
examples like the tracking example[fn:trak] and the accelerometer
example,[fn:klfl] and there are no surprises.

* Literate Code

A /literate program/[fn:litp] is a single text document that contains both
- \LaTeX{} typesetting instructions and
- source code and scripts for an application.
A literate program can be edited in any text editor and controlled with
text-based versioning tools like git, but requires other tools to extract the
typeset document and to extract the source code. My chosen tools are emacs and
org-babel.[fn:babl] In addition to extraction, called /tangling/, these tools
allow interactive evaluation of code in the original text document. A reader may
reproduce the results here by interacting with the source document.[fn:rprs] If
you wish to follow along interactively, you will need emacs and the text source
for this document. The text source for this document is found here */TODO/*. A
distribution of emacs for the Mac with adequate org-babel support is maintained
by Vincent Goulet at the University of Laval.[fn:lavl] Emacs for Linux and
Windows is easy to find, but I do not discuss it further. /Spacemacs/[fn:spcm]
offers /vim/ emulation with the tools needed for literate programming for those
who prefer /vim/.

* COMMENT Polemical Justification

Most programmers have been taught to put documentation in their source code as
formatted comments. Popular tools like [[http://www.stack.nl/~dimitri/doxygen/][Doxygen]][fn:doxy] and [[http://www.oracle.com/technetwork/articles/java/index-jsp-135444.html][Javadoc]][fn:javd]
help with this, and the industry almost universally requires them.

A much better idea is to put source code in the documentation. This is called
/literate programming/. It's better because:

1. Source code must be laid out in an order convenient for the compiler and
   tools, not in an order convenient for human reasoning. Crucial high-level
   information for human understanding can be buried in source files many levels
   down in the basement of a source tree. It's better to explain code to people
   in layered, logical order in a typeset document and have a tool rearrange the
   code into compiler-convenient order. This is called /tangling/.

1. The common practice of doc-in-code is lossy and discards /precisely/ the most
   valuable information about software, namely
   1. information about the code that is /not/ there: the trial and error that
      you don't want others to repeat, the suboptimal designs that were tried
      and discarded, the thinking and tinkering that led to the current code
      base.
   2. the higher-level structure and meaning: this is most important because
      anyone who already knows the higher-level concepts can struggle through
      source code without fancy Doxygen or Javadoc. But the reverse is not true:
      no reasonable amount of detailed, low-level, function-and-parameter
      documentation can reveal higher-level concepts, structures, diagrams,
      patterns.

2. The usual reality is that external design and architecture documents go out
   of maintenance early and forever. If you are responsible enough to maintain
   higher-level architecture and design, it's usually in multiple, external,
   separate, disconnected documents in proprietary formats. They are impossible
   to control with text-based versioning systems like git, so collaboration is
   so difficult that people don't actually do it. The advantages of text-based
   version control are so overwhelming that people end up maintaining /only/ the
   documentation that's in pure text, and that documentation is usually /only/
   buried in the source code.

3. Source-code comments are almost always in pure ascii, and there is no
   standard way that programmers will actually adopt to present typeset
   mathematics, diagrams, charts, and other vital visual aids. But org-mode
   supports \LaTeX for mathematics and Tikz,[fn:tikz], Ditaa, [fn:dtaa] and
   PlantUML[fn:plnt] for diagramming in literate programs.

4. We need documents in HTML, PDF, Word, Wiki, Markdown, and any number of other
   formats. We seek tooling that can generate all of these /plus/ the source
   directory tree from a single source document.

** What about IDEs?

Integrated Development Environments (IDEs) offer a reasonable alternative to
literate programming. IDEs can automate much of the mundane maintenance. A
downside is that everyone on a project must use compatible tools. This can get
expensive in licenses and training, and it's not practical in open-source
projects.

At the risk of contradicting myself, I am going to insist that everyone who
implements my methodology use Spacemacs, a layer on Emacs that fully supports
VIM users. Because Emacs is free, cross-platform, and general-purpose, insisting
on it is not as bad as insisting that everyone use a particular IDE. I will
argue that the goodness of the methodology presented here is sufficient reason
to adopt it.

I once tried a similar methodology based on Markdown, because anyone can edit
markdown with any text-editing tool, and I thought it easier to sell than
insisting everyone use Emacs. I was wrong. No one adopted my method, whereas
lots of people are doing literate programming with org-mode and babel in Emacs.
Why? Because the side benefits of org-mode are so overwhelming that they make
Emacs worthwhile even if you're not doing literate programming.

** What about Wiki?

A new practice using wiki pages is emerging and may mitigate this `usual
reality.' At present, the tools are primitive and unreliable, so I still edit
everything in emacs and then /try/ to paste it into terrible online editors,
often resulting in eternally spinning doughnuts. When the wiki tools become as
good as emacs and org-mode, I may change.

* This Document is Literate
** Get C to Work

First, make sure the following works[fn:obc1] in org-babel and org-babel tangle. If it
does work, you have a correctly installed C compiler.

#+begin_src C++ :includes '(<stdio.h>) :tangle k-folding.c :exports both
  int a=7;
  int b=6;
  printf("%d\n", a*b);
  // ~~> produces
#+end_src

#+RESULTS:
: 42

** Recurrence for the Mean
*** Business Code

C code is usually much longer than the corresponding Wolfram code (or Lisp, or
Haskell, or OCaml, etc.). The extra length, overall, is due mostly to the need
for manual memory management in C. However, we also don't have pattern matching
for unpacking inputs and we don't have literal list / array notation for
expressing some inputs and for packing outputs.

The goal of our C code is to make the final result as clean and as close to the
original design in Wolfram as possible. For instance, the original source for
/Recurrence for the Mean/ in paper 1[fn:klf1] is

#+BEGIN_SRC mathematica
cume[{x_, n_}, z_] := (* pattern matching for unpacking inputs *)
  With[{K = 1/(n + 1)},
   {x + K (z - x), n + 1}]; (* literal notation for packing outputs *)
Fold[cume, {0, 0}, {55, 89, 144}] (* literal notation for some inputs *)
~~> {96, 3}
#+END_SRC

The equivalent ``business'' code in C is still longer, but can see that the code
for computing the gain and for the resulting /Accumulation/ is virtually
identical (we must use an explicit multiplication operator =*=, whereas a space
suffices in Wolfram for scalar multiplication). At least the memory management
is hidden in the types /Accumulation/ and /Observation/, articulated further
below.

#+CAPTION: Business logic in C
#+NAME: c-business-logic
#+BEGIN_SRC C :results none
  {   Accumulator cume = ^(Accumulation a, Observation z)
          {   /* unpack inputs */
              T x = a.elements[0];
              T n = a.elements[1];
              /* compute gain */
              T K = 1.0 / (1.0 + n);
              /* busines logic, and packing results */
              Accumulation r;
              r.elements[0] = x + K * (z - x);
              r.elements[1] = 1.0 + n;

              return r;   };

      Accumulation x0 = zeroAccumulation ();

      Observation tmp[3] = {55, 89, 144};
      Observations zs = createObservations(3, tmp);

      Accumulation result = fold (cume, x0, zs);

      printAccumulation (result);
      return 0;   }
#+END_SRC

*** Primary Numerical Type

We abstract out the primary numerical type into the traditional =T= to make it
easier to change.

#+CAPTION: Primary numerical type
#+NAME: c-numerical-type
#+BEGIN_SRC C
  typedef double T;
#+END_SRC

*** Accumulation Type

The code for the Accumulation type is a bit elaborate, but the extra
abstractions will serve us well when we get to the Kalman filter.

The Accumulation structure presumes that all values are copied around on every
use, and that's safe, and also means that we don't need alloc & free routines
for this type. These accumulation types are usually small, so the time needed to
copy them around may be acceptable. More sophisticated memory management for
them entails more code, so we opt for keeping the code small at the cost of some
copying that could be optimized away.

Also, in the interest of saving space, specifically, staircases of closing curly
braces on lines by themselves, we adopt the /Pico/[fn:pico] style for bracing.

#+CAPTION: Accumulation type
#+NAME: c-accumulation-type
#+BEGIN_SRC C
  const size_t Accumulation_size = 3;
  typedef struct s_Accumulation
  {   T elements[Accumulation_size];   } Accumulation, * pAccumulation;

  Accumulation zeroAccumulation (void)
  {   Accumulation r;
      memset ((void *)r.elements, 0, Accumulation_size * sizeof (T));
      return r;   }

  void printAccumulation (Accumulation a)
  {   printf ("{");
      for (size_t i = 0; i < Accumulation_size; ++i)
      {   printf ("%lf", a.elements[i]);
          if (i < Accumulation_size - 1)
          {   printf (", ");   }   }
      printf ("}\n");   }
#+END_SRC

We have harmlessly used $3$ for the accumulation size because we want to reuse
this code later. We could make it variable at the cost of more unilluminating
code.

*** Observation Types

Because we don't statically know the number of observations, we must use
dynamic memory allocation. In an embedded application, we would use arena memory
(fixed-length circular buffer pools of fixed-length structs) or stack allocation
(/calloc/). Here, for brevity and because this is a testing deployment, we use
heap memory (stdlib's /malloc/ and /free/). These are unacceptable in embedded
applications because of fragmentation and unbounded execution times.

When we get to lazy streams, we won't need these at all. They're only for arrays
of observations all in memory at one time.

The primary helper type is a bounded array of /Observations/ type that includes
the length and a handy iterator-like /current/ index. Most of the code for this
type concerns explicit memory management for this helper type.

We also include an /Observation/ type, for asbstraction hygiene.

#+CAPTION: Observation types
#+NAME: c-observation-types
#+BEGIN_SRC C
  typedef T Observation, * pObservation;
  typedef struct s_BoundedArray_Observations
  {   int count;
      int current;
      pObservation observations;   } Observations;

  /*private*/pObservation allocObservationArray (int count_)
  {   /* Don't use malloc & free in embedded apps. Use arena or stack memory. */
      pObservation po = (pObservation) malloc (count_ * sizeof (Observation));
      if (NULL == po)
      {   printf ("Failed to alloc %d observations\n", count_);
          exit (-1);   }
      return po;   }

  Observations createObservations (int count_, pObservation pObservations)
  {   pObservation po = allocObservationArray (count_);
      memcpy ((void *)po, (void *)pObservations, sizeof (Observation) * count_);
      Observations result;
      result.count   = count_;
      result.current = 0;
      result.observations    = po;
      return result;   }

  void freeObservations (Observations o)
  {   /* Don't use malloc & free in embedded apps. Use arena or stack memory. */
      free ((void *)o.observations);   }
#+END_SRC

*** Accumulator Type

Our last type definition is for the /Accumulator/ function. Here we cheat a bit
and use an extension to the C language called /Blocks/,[fn:blck] which
implements full closures. We could explicitly implement enough of closures for
our purposes, but this extension is widely available with clang and llvm on
Apple computers and Linux, and it's too convenient to pass up. With compilers
for bare-metal processors in embedded systems, we might not have it and have to
do more work by hand. With this extension, the /Accumulator/ type, defined with
the hat syntax =^=, behaves just like a function pointer, which would be defined
with the ordinary pointer syntax, =*=.

#+CAPTION: Accumulator type
#+NAME: c-accumulator-type
#+BEGIN_SRC C
typedef Accumulation (^Accumulator) (Accumulation a, Observation b);
#+END_SRC

*** The Fold Over Observations

The final piece is the /fold/ operator. This particular one knows details of the
/Observations/ type, so is specific to it. We have another fold over lazy
streams, articulated below, just as with Wolfram.

#+CAPTION: Fold over observations in bounded arrays
#+NAME: c-fold-over-observations
#+BEGIN_SRC C
  Accumulation fold (Accumulator f, Accumulation x0, Observations zs)
  {   for (zs.current = 0; zs.current < zs.count; ++zs.current)
      {   x0 = f (x0, zs.observations[zs.current]);   }
      return x0;   }
#+END_SRC

*** Pulling it All Together

#+CAPTION:  Recurrence for the mean: entire program
#+BEGIN_SRC C :tangle recurrenceForTheMean.c :noweb tangle
  #include <stdio.h>
  #include <string.h>
  #include <stdlib.h>
  #include <Block.h>
  <<c-numerical-type>>
  <<c-accumulation-type>>
  <<c-observation-types>>
  <<c-accumulator-type>>
  <<c-fold-over-observations>>
  int main (int argc, char ** argv)
  <<c-business-logic>>
#+END_SRC

Tangle this code out to a C file by executing `org-babel-tangle' while
visiting this literate source code in emacs.

Compile and run the code as follows:

#+CAPTION: Build and execute script for recurrence-for-the-mean
#+BEGIN_SRC bash :exports both
gcc -Wall -Werror recurrenceForTheMean.c -o recurrenceForTheMean
./recurrenceForTheMean
#+END_SRC

#+CAPTION: Output of recurrence-for-the-mean
#+RESULTS:
| {96.000000 | 3.0 | 0.000000} |

\noindent producing results all-but-identical to those from the Wolfram language.

** FoldList and Recurrence for the Variance

The original paper introduced Wolfram's /FoldList/ along with the recurrence for
the variance. We do likewise here, implementing our own /foldList/ in C.

*** Bounded Array for Accumulations

/FoldList/ produces a list of accumulations, one for the initial accumulation
and another for each observation. With lists of observations all in memory, we
could calculate the length of the output and preallocate a list of accumlations
of the correct size, but we are not able to do that with lazy streams of
observations or asynchronous observables of observations. We opt, then, for
on-demand, dynamic memory management for the output accumulations.
``On-demand,'' here, means growing the output array as new accumulations arrive.
We use the common trick of doubling the capacity of the output array every time
the capacity is exceeded. This trick is a reasonable compromise of space and
time efficiency.

We emulate the /bounded-array/ interface created for observations, and add three
more functions to the usual /create/, /free/, and /print/.
- lastAccumulations :: returns the last accumulation in a bounded array; needed for
     /foldList/
- appendAccumulations :: appends a new accumulation to a bounded array of
     accumulations, growing the capacity if needed
- foldList :: takes an accumulator $f$, an initial accumulation $a_0$, a bounded
     array of observations $zs$, and produces a bounded array of accumulations.

#+CAPTION: Bounded array for accumulations
#+NAME: c-bounded-array-for-accumulations
#+BEGIN_SRC C
  typedef struct s_BoundedArray_Accumulations
  {   int count;
      int max;
      pAccumulation accumulations ;   } Accumulations;

  Accumulation lastAccumulations (Accumulations as)
  {   if (0 == as.count)
      {   printf ("Attempt to pull non-existent element\n");
          exit (-4);   }
      return as.accumulations[as.count - 1];   }

  Accumulations appendAccumulations (Accumulations as, Accumulation a)
  {   Accumulations result = as;
      if (result.count + 1 > result.max)
      {   /* Double the storage. */
          int new_max = 2 * result.max;
          /* Don't use malloc & free in embdded apps. Use arena or stack memory. */
          pAccumulation new = (pAccumulation)
            malloc (sizeof (Accumulation) * new_max);
          if (NULL == new)
          {   printf ("Failed to alloc %d Accumulations\n", new_max);
              exit (-2);   }
          if (result.count != result.max)
          {   printf ("Internal bugcheck\n");
              exit (-3);   }
          memset ((void *)new, 0, new_max * sizeof (Accumulation));
          memcpy ((void *)new, (void *)result.accumulations,
            (sizeof (Accumulation) * result.max));
          free ((void *) result.accumulations);
          result.accumulations = new;
          result.max = new_max;   }
      result.accumulations[result.count] = a;
      ++ result.count;
      return result;   }

  Accumulations createAccumulations (void)
  {   Accumulations result;
      const int init_size = 4;
      result.max = init_size;
      result.count = 0;
      result.accumulations = (pAccumulation)
        malloc (sizeof (Accumulation) * init_size);
      memset ((void *)result.accumulations, 0,
        sizeof (Accumulation) * init_size);
      return result;   }

  void freeAccumulations (Accumulations as)
  {   memset ((void *) as.accumulations, 0,
        (sizeof (Accumulation) * as.count));
      free ((void *) as.accumulations);   }

  void printAccumulations (Accumulations as)
  {   for (int j = 0; j < as.count; ++j )
      {   printAccumulation (as.accumulations[j]);   }   }

  Accumulations foldList (Accumulator f, Accumulation a0, Observations zs)
  {   Accumulations result = createAccumulations ();
      result = appendAccumulations (result, a0);
      for (zs.current = 0; zs.current < zs.count; ++zs.current)
      {   result = appendAccumulations (
            result,
            f(lastAccumulations(result),
            zs.observations[zs.current]));   }
          return result;   }
#+END_SRC

*** Pulling Together Recurrence for the Variance

#+CAPTION:  Recurrence for the variance: entire program
#+BEGIN_SRC C :tangle recurrenceForTheVariance.c :noweb tangle
  #include <stdio.h>
  #include <string.h>
  #include <stdlib.h>
  #include <Block.h>
  <<c-numerical-type>>
  <<c-accumulation-type>>
  <<c-observation-types>>
  <<c-accumulator-type>>
  <<c-fold-over-observations>>
  <<c-bounded-array-for-accumulations>>
  int main (int argc, char ** argv)
{   Observation tmp[3] = {55, 89, 144};
    Observations zs = createObservations(3, tmp);
    Accumulation x0 = zeroAccumulation ();
    Accumulator cume = ^(Accumulation a, Observation z)
        {   T var = a.elements[0];
            T x   = a.elements[1];
            T n   = a.elements[2];

            T K = 1.0 / (1.0 + n);
            T x2 = x + K * (z - x);
            T ssr2 = (n - 1.0) * var + K * n * (z - x) * (z - x);

            Accumulation r;
            r.elements[0] = ssr2 / (n > 1.0 ? n : 1.0);
            r.elements[1] = x2;
            r.elements[2] = n + 1.0;
            return r;   };

    Accumulations results = foldList (cume, x0, zs);
    printAccumulations (results);

    freeAccumulations (results);
    freeObservations (zs);
    return 0;   }
#+END_SRC

#+CAPTION: Build and execute script for recurrence-for-the-variance
#+BEGIN_SRC bash :exports both
gcc -Wall -Werror recurrenceForTheVariance.c -o recurrenceForTheVariance
./recurrenceForTheVariance
#+END_SRC

#+CAPTION: Output of recurrence-for-the-variance
#+RESULTS:
| {0.000000    |  0.0 | 0.000000} |
| {0.000000    | 55.0 | 1.000000} |
| {578.000000  | 72.0 | 2.000000} |
| {2017.000000 | 96.0 | 3.000000} |

This result is semantically identical to that produced by the following Wolfram
code:

#+CAPTION: Wolfram code for recurrence for the variance
#+BEGIN_SRC mathematica
cume[{var_, x_, n_}, z_] :=
  With[{K = 1/(n + 1)},
   With[{x2 = x + K (z - x),
     ssr2 = (n - 1) var + K n (z - x)^2},
    {ssr2/Max[1, n], x2, n + 1}]];
Fold[cume, {0, 0, 0}, zs]
~~> {2017, 96, 3}
#+END_SRC

* Basic Kalman Folding

** Avoiding the Inverse

In the first paper in this series, we wrote one version of the static Kalman
filter, when there are no system dynamics,[fn:klf2] as follows.

#+BEGIN_LaTeX
\begin{equation}
\label{eqn:kalman-cume-definition}
\text{cume}
\left(
\mathbold{Z}
\right)
\left(
\left\{
\mathbold{x},
\mathbold{P}
\right\},
\left\{
\mathbold{A},
\mathbold{z}
\right\}
\right) =
\left\{
\mathbold{x}+
\mathbold{K}\,
\left(
\mathbold{z}-
\mathbold{A}\,
\mathbold{x}
\right),
\mathbold{P}-
\mathbold{K}\,
\mathbold{A}\,
\mathbold{P}
\right\}
\end{equation}
#+END_LaTeX

\noindent where

#+BEGIN_LaTeX
\begin{align}
\label{eqn:kalman-gain-definition}
\mathbold{K}
&=
\mathbold{P}\,
\mathbold{A}^\intercal\,
\mathbold{D}^{-1} \\
\label{eqn:kalman-denominator-definition}
\mathbold{D}
&= \mathbold{Z} +
\mathbold{A}\,
\mathbold{P}\,
\mathbold{A}^\intercal
\end{align}
#+END_LaTeX

\noindent and all quantities are matrices, and

- \(\mathbold{Z}\) =   \({b}\times{b}\) covariance of observation noise
- \(\mathbold{x}\) =   \({n}\times{1}\) model states
- \(\mathbold{P}\) =   \({n}\times{n}\) theoretical covariance of \(\mathbold{x}\)
- \(\mathbold{A}\) =   \({b}\times{n}\) \emph{observation partials}
- \(\mathbold{z}\) =   \({b}\times{1}\) multidimensional, decorrelated observations
- \(\mathbold{K}\) =   \({n}\times{b}\) \emph{Kalman gain}
- \(\mathbold{D}\) =   \({b}\times{b}\) the Kalman denominator

Adding physical dimensions, if the physical and matrix dimensions of
\(\mathbold{x}\)
are
\(\left[\left[\mathbold{x}\right]\right]
\stackrel{\text{\tiny def}}{=}
(\mathcal{X}, n\times{1})\)
and of
\(\mathbold{z}\)
are
\(\left[\left[\mathbold{z}\right]\right]
\stackrel{\text{\tiny def}}{=}
(\mathcal{Z}, b\times{1})\), then

#+BEGIN_LaTeX
\begin{equation*}
\label{eqn:dimensional-breakdown}
\begin{array}{lccccr}
\left[\left[\mathbold{Z}\right]\right]                                       &=& (&\mathcal{Z}^2            & b\times{b}&) \\
\left[\left[\mathbold{P}\right]\right]                                       &=& (&\mathcal{X}^2            & n\times{n}&) \\
\left[\left[\mathbold{A}\right]\right]                                       &=& (&\mathcal{Z}/\mathcal{X}  & b\times{n}&) \\
\left[\left[\mathbold{A}\,\mathbold{P}\,\mathbold{A}^\intercal\right]\right] &=& (&\mathcal{Z}^2            & b\times{b}&) \\
\left[\left[\mathbold{D}\right]\right]                                       &=& (&\mathcal{Z}^2            & b\times{b}&) \\
\left[\left[\mathbold{P}\,\mathbold{A}^\intercal\right]\right]               &=& (&\mathcal{X}\,\mathcal{Z} & n\times{b}&) \\
\left[\left[\mathbold{K}\right]\right]                                       &=& (&\mathcal{X}/\mathcal{Z}  & n\times{b}&)
\end{array}
\end{equation*}
#+END_LaTeX

While an expression with an explicit inverse is mathematically acceptable,
inverses are numerically risky, expensive in storage, slow to compute, and
usually not necessary.[fn:ditm] LAPACK can solve linear systems very
efficiently, much more efficiently than it can invert matrices.
Therefore, we rewrite the basic filter to avoid computing
$\mathbold{D}^{-1}$.

If
\(\textrm{DiRes}=\mathbold{D}^{-1}\,(\mathbold{z}-\mathbold{A}\,\mathbold{x})\)
is the solution of the linear equation
\(\mathbold{D}\times\textrm{\textrm{DiRes}}=(\mathbold{z}-\mathbold{A}\,\mathbold{x})\), and if
$\mathbold{K}=\mathbold{P}\,\mathbold{A}^\intercal\,\mathbold{D}^{-1}$, then
$\mathbold{K}\,(\mathbold{z}-\mathbold{A}\,\mathbold{x})=\mathbold{P}\,\mathbold{A}^\intercal\,\textrm{DiRes}$
and the Kalman state-update is $\mathbold{x}\leftarrow\mathbold{x}+\mathbold{P}\,\mathbold{A}^\intercal\,\textrm{DiRes}$.
Likewise, if $\textrm{DiAP}=\mathbold{D}^{-1}\,\mathbold{A}\,\mathbold{P}$ is
the solution of the linear equation
$\mathbold{D}\times\textrm{DiAP}=\mathbold{A}\,\mathbold{P}$, then
$\mathbold{K}\,\mathbold{A}\,\mathbold{P}=\mathbold{P}\,\mathbold{A}^\intercal\,\textrm{DiAP}$
and the Kalman covariance update is $\mathbold{P}\leftarrow\mathbold{P}-\mathbold{P}\,\mathbold{A}^\intercal\,\textrm{DiAP}$.

In Wolfram, our original, foldable Kalman filter was

#+BEGIN_LaTeX
\begin{verbatim}
kalman[Z_][{x_, P_}, {A_, z_}] :=
  Module[{D, K},
   D = Z + A.P.Transpose[A];
   K = P.Transpose[A].Inverse[D];
   {x + K.(z - A.x), P - K.A.P}];
\end{verbatim}
#+END_LaTeX

\noindent and our new minimal, foldable filter is

#+BEGIN_LaTeX
\begin{verbatim}
noInverseKalman[Z_][{x_, P_}, {A_, z_}] :=
  Module[{PAT, D, KRes, KAP},
   PAT = P.Transpose[A];
   D = Z + A.PAT;
   KRes = PAT.LinearSolve[D, z - A.x];
   KAP = PAT.LinearSolve[D, A.P];
   {x + KRes, P - KAP}];
\end{verbatim}
#+END_LaTeX

This reads almost as easily as the original if one reads =LinearSolve= as
/invert-first-argument-and-matrix-multiply/.

Notice we do not compute the Kalman gain explicitly, but only use it in
combination with other matrices. This produces results indistinguishable from
the original, up to floating-point issues, when folded over any source of data.

LAPACK offers a function, =dposv=,[fn:dpos][fn:ndoc] that solves this linear
system when $\mathbold{D}$ is symmetric and positive definite. Because
$\mathbold{D}$ is the sum of a diagonal matrix $\mathbold{Z}$ and a symmetric,
positive-definite matrix $\mathbold{A}\,\mathbold{P}\,\mathbold{A}^\intercal$,
it should also be symmetric and positive definite. Therefore, we transcribe the
code above into C as follows

** Fortran and C

We need matrix operations, and we choose CBLAS[fn:cbls] and LAPACKE.[fn:lpke]

** COMMENT Get GSL to Work

Get gsl, build it (=./configure=, =make=),
check it (=make check=), install it (=make install=). The following should work
if you use all the default settings; you may need to install /gfortran/
separately.

You must link these against =libgsl=. Note the flags on the
=begin-src= line if you are visiting the org-mode file in emacs.


#+begin_src C++ :includes '(<stdio.h> <gsl/gsl_sf_bessel.h>) :flags -lgsl -lm :exports both
  double x = 5.0;
  double y = gsl_sf_bessel_J0 (x);
  printf ("J0(%g) = %.18e\n", x, y);
  // ~~> produces
#+end_src

#+RESULTS:
: J0(5) = -1.775967713143382642e-01

#+begin_src C++ :includes '(<stdio.h> <gsl/gsl_block.h>) :flags -lgsl -lm :exports both
  gsl_block * b = gsl_block_alloc (100);

  printf ("length of block = %zu\n", b->size);
  printf ("block data address = %p\n", b->data);

  gsl_block_free (b);
  // ~~> produces
#+end_src

#+RESULTS:
| length | of   | block   | = |            100 |
| block  | data | address | = | 0x7fe9a0c03580 |

#+begin_src C++ :includes '(<stdio.h> <gsl/gsl_vector.h>) :flags -lgsl -lm :exports both
   int i;
   gsl_vector * v = gsl_vector_alloc (3);

   for (i = 0; i < 3; i++)
   {   gsl_vector_set (v, i, 1.23 + i);   }

   for (i = 0; i < 3; i++)
   {   printf ("v_%d = %g\n", i, gsl_vector_get (v, i));   }

   gsl_vector_free (v);
  // ~~> produces
#+end_src

#+RESULTS:
| v_0 | = | 1.23 |
| v_1 | = | 2.23 |
| v_2 | = | 3.23 |

#+begin_src C++ :includes '(<stdio.h> <gsl/gsl_matrix.h>) :flags -lgsl -lm :exports both
   int i, j;
   gsl_matrix * m = gsl_matrix_alloc (10, 3);

   for (i = 0; i < 10; i++)
     for (j = 0; j < 3; j++)
       gsl_matrix_set (m, i, j, 0.23 + 100*i + j);

   for (i = 0; i < 10; i++)
     for (j = 0; j < 3; j++)
       printf ("m(%d,%d) = %g\n", i, j,
               gsl_matrix_get (m, i, j));

   gsl_matrix_free (m);
  // ~~> produces
#+end_src

#+RESULTS:
| m(0 | 0) = 0.23   |
| m(0 | 1) = 1.23   |
| m(0 | 2) = 2.23   |
| m(1 | 0) = 100.23 |
| m(1 | 1) = 101.23 |
| m(1 | 2) = 102.23 |
| m(2 | 0) = 200.23 |
| m(2 | 1) = 201.23 |
| m(2 | 2) = 202.23 |
| m(3 | 0) = 300.23 |
| m(3 | 1) = 301.23 |
| m(3 | 2) = 302.23 |
| m(4 | 0) = 400.23 |
| m(4 | 1) = 401.23 |
| m(4 | 2) = 402.23 |
| m(5 | 0) = 500.23 |
| m(5 | 1) = 501.23 |
| m(5 | 2) = 502.23 |
| m(6 | 0) = 600.23 |
| m(6 | 1) = 601.23 |
| m(6 | 2) = 602.23 |
| m(7 | 0) = 700.23 |
| m(7 | 1) = 701.23 |
| m(7 | 2) = 702.23 |
| m(8 | 0) = 800.23 |
| m(8 | 1) = 801.23 |
| m(8 | 2) = 802.23 |
| m(9 | 0) = 900.23 |
| m(9 | 1) = 901.23 |
| m(9 | 2) = 902.23 |

** COMMENT BLAS Through GSL

You must link this against =libgsl= and =libblas=. Note the flags on the
=begin-src= line if you are visiting the org-mode file in emacs.

#+begin_src C++ :includes '(<stdio.h> <gsl/gsl_blas.h>) :flags -lgsl -lblas -lm :exports both
  /* DGEMM will transpose the following matrix. It's just a copy of a. */
  double at[] = {1.0,  0.0,  0.0,  0.0,
                 1.0,  1.0,  1.0,  1.0,
                 1.0, -1.0,  1.0, -1.0,
                 1.0, -2.0,  4.0, -8.0,
                 1.0,  2.0,  4.0,  8.0 };

  double a[] = { 1.0,  0.0,  0.0,  0.0,
                 1.0,  1.0,  1.0,  1.0,
                 1.0, -1.0,  1.0, -1.0,
                 1.0, -2.0,  4.0, -8.0,
                 1.0,  2.0,  4.0,  8.0 };

  double c[] = { 0.00, 0.00, 0.00, 0.00,
                 0.00, 0.00, 0.00, 0.00,
                 0.00, 0.00, 0.00, 0.00,
                 0.00, 0.00, 0.00, 0.00 };

  gsl_matrix_view AT = gsl_matrix_view_array(at, 5, 4);
  gsl_matrix_view A  = gsl_matrix_view_array(a,  5, 4);
  gsl_matrix_view C  = gsl_matrix_view_array(c,  4, 4);

  /* Compute C = AT.A */

  gsl_blas_dgemm (CblasTrans, CblasNoTrans,
                  1.0, &AT.matrix, &A.matrix,
                  0.0, &C.matrix);

  printf ("%g, %g, %g, %g\n", c[ 0], c[ 1], c[ 2], c[ 3]);
  printf ("%g, %g, %g, %g\n", c[ 4], c[ 5], c[ 6], c[ 7]);
  printf ("%g, %g, %g, %g\n", c[ 8], c[ 9], c[10], c[11]);
  printf ("%g, %g, %g, %g\n", c[12], c[13], c[14], c[15]);
  // ~~> produces
#+end_src

#+RESULTS:
|  5 |  0 | 10 |   0 |
|  0 | 10 |  0 |  34 |
| 10 |  0 | 34 |   0 |
|  0 | 34 |  0 | 130 |

** COMMENT BLAS and CBLAS

The most direct way to access BLAS from C is through its supported CBLAS
wrapper. Because the layer is very thin, we have visibility into all operations
going to the metal.

#+BEGIN_SRC C :includes '(<stdio.h> <stdlib.h> <string.h> <cblas.h>) :flags -lcblas :exports both
  /* DGEMM computes C <-- alpha * A   . B + beta * C
     or             C <-- alpha * A^T . B + beta * C

     In the first case, A is m by k, B is k by n, and C is m by n.
     In the second case A is k by m, B is k by n, and C is m by n.

     We want to compute A^T . A.
   */

  int m      = 4;    /* Size of A  Column ( the number of rows )    */
  int k      = 5;    /* Size of A  Row    ( the number of columns ) */
  int n      = 4;    /* Size of AT Column */
  int lda    = 5;    /* Leading dimension of 5 * 4 matrix is 5 */
  int ldat   = 4;
  int ld_ata = 4;

  double alpha = 1;
  double beta  = 0;

  /* In our application, a plays the role of matrix B. We only have to look at one
     bit of poison, here: we write the array in row-major order, but fortran
     "sees" it in column-major order. That means that the leading dimension of the
     array a is the number of rows, or the number of elements between successive
     columns, or the stride. We could do the same calculation entirely in
     row-major form, but why? */

  /* k = 5 rows, n = 4 columns */
  double a[] = { /* col 0 */  1.0,  1.0,  1.0,  1.0,  1.0,
                 /* col 1 */  0.0,  1.0, -1.0, -2.0,  2.0,
                 /* col 2 */  0.0,  1.0,  1.0,  4.0,  4.0,
                 /* col 3 */  0.0,  1.0, -1.0, -8.0,  8.0 };

  /* Clear the result's memory, for paranoia. Memset is fast. */
  double ata[ 4 * 4 ];
  memset (ata, 0, 4 * 4 * sizeof (double));

  /* Compute C <-- alpha * A^T . A + beta * C */

  cblas_dgemm (CblasColMajor,
               CblasTrans, CblasNoTrans,
               m, n, k,
               alpha,
               /* We can just refer to the original matrix here; it
                  won't be perturbed. */
               a, k, /* LD of at before DGENN's internal transpose. */
               a, k,
               beta,
               ata, n);

  for (int r = 0; r < n; ++r)
  { printf ("%g, %g, %g, %g\n", ata[r], ata[n + r], ata[2*n + r], ata[3*n + r]); }
#+END_SRC

#+RESULTS:
|  5 |  0 | 10 |   0 |
|  0 | 10 |  0 |  34 |
| 10 |  0 | 34 |   0 |
|  0 | 34 |  0 | 130 |

** LAPACK and LAPACKE

*** COMMENT gfortran

Make sure you have =gfortran= installed:

#+BEGIN_SRC bash
gfortran --version
#+END_SRC

#+RESULTS:
| GNU       | Fortran | (Homebrew    | gcc    | 5.3.0)   | 5.3.0       |         |        |          |           |         |      |
| Copyright | (C)     | 2015         | Free   | Software | Foundation, | Inc.    |        |          |           |         |      |
|           |         |              |        |          |             |         |        |          |           |         |      |
| GNU       | Fortran | comes        | with   | NO       | WARRANTY,   | to      | the    | extent   | permitted | by      | law. |
| You       | may     | redistribute | copies | of       | GNU         | Fortran |        |          |           |         |      |
| under     | the     | terms        | of     | the      | GNU         | General | Public | License. |           |         |      |
| For       | more    | information  | about  | these    | matters,    | see     | the    | file     | named     | COPYING |      |
|           |         |              |        |          |             |         |        |          |           |         |      |

*** COMMENT LAPACK

Get LAPACK.[fn:lpck]
This builds BLAS as a side effect.

#+BEGIN_SRC bash
pushd ~/Documents/lapack-3.6.0
cmake .
make
make test
#+END_SRC

#+RESULTS:

#+BEGIN_SRC bash :export both
pushd ~/Documents/lapack-3.6.0
make install
#+END_SRC

#+RESULTS:
| ~/Documents/lapack-3.6.0 | ~/Documents/kalman-folding |                                                                 |          |            |
| [                        | 5%]                        | Built                                                           | target   | blas       |
| [                        | 59%]                       | Built                                                           | target   | lapack     |
| [                        | 61%]                       | Built                                                           | target   | tmglib     |
| [                        | 62%]                       | Built                                                           | target   | xlintstzc  |
| [                        | 63%]                       | Built                                                           | target   | xlintstrfz |
| [                        | 69%]                       | Built                                                           | target   | xlintstc   |
| [                        | 75%]                       | Built                                                           | target   | xlintstz   |
| [                        | 76%]                       | Built                                                           | target   | xlintstrfc |
| [                        | 76%]                       | Built                                                           | target   | xlintstrfs |
| [                        | 81%]                       | Built                                                           | target   | xlintstd   |
| [                        | 82%]                       | Built                                                           | target   | xlintstrfd |
| [                        | 82%]                       | Built                                                           | target   | xlintstds  |
| [                        | 87%]                       | Built                                                           | target   | xlintsts   |
| [                        | 90%]                       | Built                                                           | target   | xeigtstc   |
| [                        | 93%]                       | Built                                                           | target   | xeigtstz   |
| [                        | 97%]                       | Built                                                           | target   | xeigtsts   |
| [100%]                   | Built                      | target                                                          | xeigtstd |            |
| Install                  | the                        | project...                                                      |          |            |
| --                       | Install                    | configuration:                                                  |          |            |
| --                       | Installing:                | /usr/local/lib/cmake/lapack-3.6.0/lapack-targets.cmake          |          |            |
| --                       | Installing:                | /usr/local/lib/cmake/lapack-3.6.0/lapack-targets-noconfig.cmake |          |            |
| --                       | Installing:                | /usr/local/lib/pkgconfig/lapack.pc                              |          |            |
| --                       | Installing:                | /usr/local/lib/cmake/lapack-3.6.0/lapack-config.cmake           |          |            |
| --                       | Installing:                | /usr/local/lib/cmake/lapack-3.6.0/lapack-config-version.cmake   |          |            |
| --                       | Installing:                | /usr/local/lib/pkgconfig/blas.pc                                |          |            |
| --                       | Installing:                | /usr/local/lib/libblas.a                                        |          |            |
| --                       | Installing:                | /usr/local/lib/liblapack.a                                      |          |            |
| --                       | Installing:                | /usr/local/lib/libtmglib.a                                      |          |            |

*** COMMENT LAPACKE

This is the C interface to LAPACK.  It does not come up as trivially as does
GSL. I had to move some files around manually.
The following mercilessly hacks around a couple of
problems in the build of =examples=, but it's enough to get the example working.

#+BEGIN_SRC bash
pushd ~/Documents/lapack-3.6.0
cp make.inc.example make.inc
cd LAPACKE
make lapacke
#+END_SRC

#+RESULTS:

#+BEGIN_SRC bash :export both
pushd ~/Documents/lapack-3.6.0
find . -name "*.a"
#+END_SRC

#+RESULTS:
| ~/Documents/lapack-3.6.0 | ~/Documents/kalman-folding |
| ./lib/libblas.a          |                            |
| ./lib/liblapack.a        |                            |
| ./lib/libtmglib.a        |                            |
| ./liblapacke.a           |                            |

#+BEGIN_SRC bash :export both
pushd ~/Documents/lapack-3.6.0
cd LAPACKE
cp ./include/lapacke*.h /usr/local/include
cd example
cp ../../liblapacke.a /usr/local/lib
cp ../../lib/*.a ../..
cp ../../libblas.a ../../librefblas.a
make
#+END_SRC

#+RESULTS:
|  ~/Documents/lapack-3.6.0 | ~/Documents/kalman-folding |                       |                    |         |                         |
|                  gfortran |   example_DGESV_rowmajor.o | lapacke_example_aux.o |                  \ |         |                         |
|                           |         ../../liblapacke.a |     ../../liblapack.a | ../../librefblas.a |      -o | xexample_DGESV_rowmajor |
| ./xexample_DGESV_rowmajor |                            |                       |                    |         |                         |
|                           |                            |                       |                    |         |                         |
|                     Entry |                     Matrix |                     A |                    |         |                         |
|                      -0.5 |                      -0.37 |                  0.26 |              -0.04 |    0.03 |                         |
|                     -0.28 |                      -0.45 |                  0.18 |               0.18 |    0.43 |                         |
|                     -0.12 |                       0.02 |                  0.33 |              -0.47 |   -0.45 |                         |
|                      0.03 |                       0.17 |                 -0.49 |              -0.12 |   -0.43 |                         |
|                     -0.08 |                       0.19 |                  0.09 |               0.43 |    0.35 |                         |
|                           |                            |                       |                    |         |                         |
|                     Right |                       Rand |                  Side |                  b |         |                         |
|                      0.03 |                            |                       |                    |         |                         |
|                     -0.41 |                            |                       |                    |         |                         |
|                      0.15 |                            |                       |                    |         |                         |
|                     -0.08 |                            |                       |                    |         |                         |
|                       0.2 |                            |                       |                    |         |                         |
|                           |                            |                       |                    |         |                         |
|             LAPACKE_dgesv |                (row-major, |           high-level) |            Example | Program | Results                 |
|                           |                            |                       |                    |         |                         |
|                  Solution |                            |                       |                    |         |                         |
|                      7.74 |                            |                       |                    |         |                         |
|                     -9.08 |                            |                       |                    |         |                         |
|                      6.77 |                            |                       |                    |         |                         |
|                     16.57 |                            |                       |                    |         |                         |
|                    -15.01 |                            |                       |                    |         |                         |
|                           |                            |                       |                    |         |                         |
|                   Details |                         of |                    LU |      factorization |         |                         |
|                      -0.5 |                      -0.37 |                  0.26 |              -0.04 |    0.03 |                         |
|                      0.17 |                       0.25 |                  0.05 |               0.44 |    0.34 |                         |
|                     -0.06 |                        0.6 |                 -0.51 |              -0.38 |   -0.64 |                         |
|                      0.23 |                       0.43 |                  -0.5 |              -0.83 |   -0.92 |                         |
|                      0.56 |                      -0.99 |                 -0.16 |              -0.69 |    0.02 |                         |
|                           |                            |                       |                    |         |                         |
|                     Pivot |                    indices |                       |                    |         |                         |
|                         1 |                          5 |                     4 |                  4 |       5 |                         |
|                  gfortran |   example_DGESV_colmajor.o | lapacke_example_aux.o |                  \ |         |                         |
|                           |         ../../liblapacke.a |     ../../liblapack.a | ../../librefblas.a |      -o | xexample_DGESV_colmajor |
| ./xexample_DGESV_colmajor |                            |                       |                    |         |                         |
|                           |                            |                       |                    |         |                         |
|                     Entry |                     Matrix |                     A |                    |         |                         |
|                      -0.5 |                      -0.37 |                  0.26 |              -0.04 |    0.03 |                         |
|                     -0.28 |                      -0.45 |                  0.18 |               0.18 |    0.43 |                         |
|                     -0.12 |                       0.02 |                  0.33 |              -0.47 |   -0.45 |                         |
|                      0.03 |                       0.17 |                 -0.49 |              -0.12 |   -0.43 |                         |
|                     -0.08 |                       0.19 |                  0.09 |               0.43 |    0.35 |                         |
|                           |                            |                       |                    |         |                         |
|                     Right |                       Rand |                  Side |                  b |         |                         |
|                      0.03 |                            |                       |                    |         |                         |
|                     -0.41 |                            |                       |                    |         |                         |
|                      0.15 |                            |                       |                    |         |                         |
|                     -0.08 |                            |                       |                    |         |                         |
|                       0.2 |                            |                       |                    |         |                         |
|                           |                            |                       |                    |         |                         |
|             LAPACKE_dgesv |                (row-major, |           high-level) |            Example | Program | Results                 |
|                           |                            |                       |                    |         |                         |
|                  Solution |                            |                       |                    |         |                         |
|                      7.74 |                            |                       |                    |         |                         |
|                     -9.08 |                            |                       |                    |         |                         |
|                      6.77 |                            |                       |                    |         |                         |
|                     16.57 |                            |                       |                    |         |                         |
|                    -15.01 |                            |                       |                    |         |                         |
|                           |                            |                       |                    |         |                         |
|                   Details |                         of |                    LU |      factorization |         |                         |
|                      -0.5 |                      -0.37 |                  0.26 |              -0.04 |    0.03 |                         |
|                      0.17 |                       0.25 |                  0.05 |               0.44 |    0.34 |                         |
|                     -0.06 |                        0.6 |                 -0.51 |              -0.38 |   -0.64 |                         |
|                      0.23 |                       0.43 |                  -0.5 |              -0.83 |   -0.92 |                         |
|                      0.56 |                      -0.99 |                 -0.16 |              -0.69 |    0.02 |                         |
|                           |                            |                       |                    |         |                         |
|                     Pivot |                    indices |                       |                    |         |                         |
|                         1 |                          5 |                     4 |                  4 |       5 |                         |
|                  gfortran |   example_DGELS_rowmajor.o | lapacke_example_aux.o |                  \ |         |                         |
|                           |         ../../liblapacke.a |     ../../liblapack.a | ../../librefblas.a |      -o | xexample_DGELS_rowmajor |
| ./xexample_DGELS_rowmajor |                            |                       |                    |         |                         |
|                           |                            |                       |                    |         |                         |
|                     Entry |                     Matrix |                     A |                    |         |                         |
|                       1.0 |                        1.0 |                   1.0 |                    |         |                         |
|                       2.0 |                        3.0 |                   4.0 |                    |         |                         |
|                       3.0 |                        5.0 |                   2.0 |                    |         |                         |
|                       4.0 |                        2.0 |                   5.0 |                    |         |                         |
|                       5.0 |                        4.0 |                   3.0 |                    |         |                         |
|                           |                            |                       |                    |         |                         |
|                     Right |                       Hand |                  Side |                  b |         |                         |
|                     -10.0 |                       -3.0 |                       |                    |         |                         |
|                      12.0 |                       14.0 |                       |                    |         |                         |
|                      14.0 |                       12.0 |                       |                    |         |                         |
|                           |                            |                       |                    |         |                         |
|             LAPACKE_dgels |                (row-major, |           high-level) |            Example | Program | Results                 |
|                           |                            |                       |                    |         |                         |
|                  Solution |                            |                       |                    |         |                         |
|                       2.0 |                        1.0 |                       |                    |         |                         |
|                       1.0 |                        1.0 |                       |                    |         |                         |
|                       1.0 |                        2.0 |                       |                    |         |                         |
|                           |                            |                       |                    |         |                         |
|                  gfortran |   example_DGELS_colmajor.o | lapacke_example_aux.o |                  \ |         |                         |
|                           |         ../../liblapacke.a |     ../../liblapack.a | ../../librefblas.a |      -o | xexample_DGELS_colmajor |
| ./xexample_DGELS_colmajor |                            |                       |                    |         |                         |
|                           |                            |                       |                    |         |                         |
|                     Entry |                     Matrix |                     A |                    |         |                         |
|                       1.0 |                        1.0 |                   1.0 |                    |         |                         |
|                       2.0 |                        3.0 |                   4.0 |                    |         |                         |
|                       3.0 |                        5.0 |                   2.0 |                    |         |                         |
|                       4.0 |                        2.0 |                   5.0 |                    |         |                         |
|                       5.0 |                        4.0 |                   3.0 |                    |         |                         |
|                           |                            |                       |                    |         |                         |
|                     Right |                       Hand |                  Side |                  b |         |                         |
|                     -10.0 |                       -3.0 |                       |                    |         |                         |
|                      12.0 |                       14.0 |                       |                    |         |                         |
|                      14.0 |                       12.0 |                       |                    |         |                         |
|                           |                            |                       |                    |         |                         |
|             LAPACKE_dgels |                (col-major, |           high-level) |            Example | Program | Results                 |
|                           |                            |                       |                    |         |                         |
|                  Solution |                            |                       |                    |         |                         |
|                       2.0 |                        1.0 |                       |                    |         |                         |
|                       1.0 |                        1.0 |                       |                    |         |                         |
|                       1.0 |                        2.0 |                       |                    |         |                         |
|                           |                            |                       |                    |         |                         |

*** COMMENT Intermediate LAPACK Samples

Here's an example where a singular matrix can't be inverted, and LAPACK tells us
so by depositing a $3$  in =errorHandler=.  Change the matrix to a non-singular
one and you should see a $0$ in =errorHandler=.

#+BEGIN_SRC C :includes '(<stdio.h> <gsl/gsl_blas.h>) :flags -llapack -llapacke :exports both :tangle SOexample.c
  #include <stddef.h>
  #include <lapacke.h>
  int N = 3;
  int NN = 9;
  double M[3][3] = { {1 , 2 , 3},
                     {4 , 5 , 6},
                     {7 , 8 , 9} };
  int pivotArray[3]; //since our matrix has three rows
  int errorHandler;
  double lapackWorkspace[9];

  // dgetrf(M,N,A,LDA,IPIV,INFO) means invert LDA columns of an M by N matrix
  // called A, sending the pivot indices to IPIV, and spitting error information
  // to INFO. also don't forget (like I did) that when you pass a two-dimensional
  // array to a function you need to specify the number of "rows"
  dgetrf_(&N, &N, M[0], &N, pivotArray, &errorHandler);
  printf ("dgetrf eh, %d, should be zero\n", errorHandler);

  dgetri_(&N, M[0], &N, pivotArray, lapackWorkspace, &NN, &errorHandler);
  printf ("dgetri eh, %d, should be zero\n", errorHandler);

  for (size_t row = 0; row < N; ++row)
  {   for (size_t col = 0; col < N; ++col)
      {   printf ("%g", M[row][col]);
          if (N-1 != col)
          {   printf (", ");   }   }
      if (N-1 != row)
      {   printf ("\n");   }   }
  // ~~> produces
#+END_SRC

#+RESULTS:
| dgetrf eh |        3 | should be zero |
| dgetri eh |        3 | should be zero |
|         3 | 0.333333 |       0.666667 |
|         6 |        2 |            0.5 |
|         9 |        4 |              0 |

Here is an example of inverting a matrix, time calling the underlying fortran
library directly:

#+BEGIN_SRC C :includes '(<stdio.h> <stddef.h>) :flags -llapack :exports both :tangle foo.c
  int N = 3;
  int NN = 9;
  /* The following input appears in row-major order. The underlying fortran code
     'sees' the transpose of this matrix, i.e., the same data in column-major
     order. We print the result again in row-major order, so, although the result
     is actually the inverse of the transpose of this matrix, it looks right
     because the inverse of the transpose is the transpose of the inverse. */
  double M[3][3] = { {1 , 2 ,  3},
                     {4 , 5 ,  6},
                     {7 , 8 , 19} };
  int pivotArray[3]; //since our matrix has three rows
  int errorHandler;
  double lapackWorkspace[9];

  /*
    SUBROUTINE DGETRF( M, N, A, LDA, IPIV, INFO )
    ,*
    ,*  -- LAPACK routine (version 3.1) --
    ,*     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
    ,*     November 2006
    ,*
    ,*     .. Scalar Arguments ..
    INTEGER            INFO, LDA, M, N
    ,*     ..
    ,*     .. Array Arguments ..
    INTEGER            IPIV( * )
    DOUBLE PRECISION   A( LDA, * )
    ,*/

  extern void dgetrf_ (int * m, int * n, double * A, int * LDA, int * IPIV,
                       int * INFO);

  /* from http://www.netlib.no/netlib/lapack/double/dgetri.f
    SUBROUTINE DGETRI( N, A, LDA, IPIV, WORK, LWORK, INFO )
    ,*
    ,*  -- LAPACK routine (version 3.1) --
    ,*     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
    ,*     November 2006
    ,*
    ,*     .. Scalar Arguments ..
    INTEGER            INFO, LDA, LWORK, N
    ,*     ..
    ,*     .. Array Arguments ..
    INTEGER            IPIV( * )
    DOUBLE PRECISION   A( LDA, * ), WORK( * )
    ,*/

  extern void dgetri_ (int * n, double * A, int * LDA, int * IPIV,
                       double * WORK, int * LWORK, int * INFO);

  // dgetrf(M,N,A,LDA,IPIV,INFO) means invert LDA columns of an M by N matrix
  // called A, sending the pivot indices to IPIV, and spitting error information
  // to INFO. also don't forget (like I did) that when you pass a two-dimensional
  // array to a function you need to specify the number of "rows"
  dgetrf_(&N, &N, M[0], &N, pivotArray, &errorHandler);
  printf ("dgetrf eh, %d, should be zero\n", errorHandler);

  dgetri_(&N, M[0], &N, pivotArray, lapackWorkspace, &NN, &errorHandler);
  printf ("dgetri eh, %d, should be zero\n", errorHandler);

  for (size_t row = 0; row < N; ++row)
   {   for (size_t col = 0; col < N; ++col)
       {   printf ("%g", M[row][col]);
           if (N-1 != col)
           {   printf (", ");   }   }
       if (N-1 != row)
       {   printf ("\n");   }   }
  // ~~> produces
#+END_SRC

#+RESULTS:
| dgetrf eh |         0 | should be zero |
| dgetri eh |         0 | should be zero |
|  -1.56667 |  0.466667 |            0.1 |
|   1.13333 | 0.0666667 |           -0.2 |
|       0.1 |      -0.2 |            0.1 |

*** COMMENT KF with LAPACK

On balance, it's better to get things working in row-major mode because the C
code reads much easier. Even though it would seem to be easy to keep
column-major mode straight in one's mind --- just mentally transpose every
matrix, or, maybe just some of them --- It slows down my
debugging because it adds one more thing that can go wrong at every
step. Adding one more thing to go wrong at every step doubles your
debugging time.

After debugging row-major mode, if you need column-major mode for speed,
optimize the calculations bit-by-bit.

*** Full Least-Squares Without Fold

#+BEGIN_SRC C :includes '(<stdio.h> <stdlib.h> <string.h> <cblas.h> <lapacke.h>) :flags -lcblas -llapacke -llapack :exports both
  const int    m = 5;
  const int    n = 4;

  double A[m * n] = { 1,  0.,  0.,  0.,
                      1,  1.,  1.,  1.,
                      1, -1.,  1., -1.,
                      1, -2.,  4., -8.,
                      1,  2.,  4.,  8. };

  // Compute Transpose[A].A; A is not disturbed.

  double AtA[n * n];
  memset (AtA, 0, n * n * sizeof (double));

  cblas_dgemm (CblasRowMajor, CblasTrans, CblasNoTrans,
               n, n, m, 1,
               A, n, // LDA is pre-transpose
               A, n,
               0,
               AtA, n);

  for (int r = 0; r < n; ++r)
  {   for (int c = 0; c < n; ++c)
      {   printf ("%g ", AtA[c + r * n]);   }
      printf ("\n");   }
  printf ("\n");

  // Compute Transpose[A].z; neither A nor z is disturbed. Results are deposited
  // into Atz.

  double z[m] = {-2.28442, -4.83168, -10.4601, 1.40488, -40.8079};

  double Atz[n];

  cblas_dgemv (CblasRowMajor, CblasTrans,
               m, n, 1,
               A, n,
               z, 1, 0,
               Atz, 1);

  for (int i = 0; i < n; ++i)
  {   printf ("%g ", Atz[i]);   }
  printf ("\n");

  // Solve At.A.x = At.z = Atz. Unlike the CBLAS routines, the input storage
  // locations are modified. The Cholesky decomposition of AtA is deposited into
  // AtA, in-place, and the solution is deposited into Atz. To preserve these
  // matrices, it's necessary to copy them first.

  // The documentation for LAPACKE_dposv has an apparent error (see
  // http://tinyurl.com/htvod3e). It states that the leading dimension of B must
  // be >= max(1, N), but we suspect it should say >= max(1, NRHS). The results
  // are definitely wrong if N is used as LDB.

  // The results of this computation are identical to those from Mathematica. This
  // is not surprising because Mathematica probably uses LAPACK internally.

  lapack_int LAPACKE_dposv( int matrix_layout, char uplo, lapack_int n,
                            lapack_int nrhs, double* a, lapack_int lda, double* b,
                            lapack_int ldb );

  lapack_int result = LAPACKE_dposv (LAPACK_ROW_MAJOR, 'U', n, 1, AtA, n, Atz, 1);

  printf ("%d\n\n", result);

  for (int i = 0; i < n; ++i)
  {   printf ("%g ", Atz[i]);   }
  printf ("\n");

#+END_SRC

#+RESULTS:
|        5 |        0 |       10 |        0 |
|        0 |       10 |        0 |       34 |
|       10 |        0 |       34 |        0 |
|        0 |       34 |        0 |      130 |
|          |          |          |          |
| -56.9792 | -78.7971 | -172.904 | -332.074 |
|        0 |          |          |          |
|          |          |          |          |
| -2.97507 |  7.27001 | -4.21039 |  -4.4558 |

*** Foldable Kalman Without Inverse

#+BEGIN_SRC C :tangle qux.c
  /*
    Copyright 2016 Brian C. Beckman

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
  ,*/
  /* This is an educational example only, not suitable for real applications.
   ,*/
  #include <stdio.h>
  #include <stdlib.h>
  #include <string.h>
  #include <cblas.h>
  #include <lapacke.h>

  void printm (char * nym, double * m, int rows, int cols)
  {   printf ("%s\n", nym);
      for (int r = 0; r < rows; ++r)
      {   for (int c = 0; c < cols; ++c)
          {   printf ("%g ", m[c + r * cols]);   }
          printf ("\n");   }
      printf ("\n");   }

  void kalman (int b,        /* # rows, cols, in Z; # rows in z */
               int n,        /* # rows, cols, in P; # rows in x */
               double * IdN, /* n x n identity matrix */
               double * Z,   /* b x b observation covariance */
               double * x,   /* n x 1, current state */
               double * P,   /* n x n, current covariance */
               double * A,   /* b x n, current observation partials */
               double * z    /* b x 1, current observation vector */
               ) {

      /* Transcribe the following Wolfram code (the intermediate matrices are not
       ,* necessary in Wolfram, but we need them in C).
       ,*
       ,* noInverseKalman[Z_][{x_, P_}, {A_, z_}] :=
       ,*   Module[{PAT, D, DiRes, DiAP, KRes, KAP},
       ,*    PAT = P.Transpose[A];               (* n x b *)
       ,*    D = Z + A.PAT;                      (* b x b *)
       ,*    DiRes = LinearSolve[D, z - A.x];    (* b x 1 *)
       ,*    KRes = PAT.DiRes;                   (* n x 1 *)
       ,*    DiAP = LinearSolve[D, A.P];         (* b x n *)
       ,*    KAP = PAT.DiAP;                     (* n x n *)
       ,*    {x + KRes, P - KAP}];
       ,*/


      /* Use dgemm for P.A^T because dsymm doesn't offer a way to transpose the
         right-hand multiplicand. */

      /*
       ,*      PAT              P           AT
       ,*       b               n           b
       ,*  n / * * \     n / * * * * \ n / * * \
       ,*    | * * |  <--  | * * * * |   | * * |
       ,*    | * * |       | * * * * |   | * * |
       ,*    \ * * /       \ * * * * /   \ * * /
       ,*
       ,*/

      double PAT[n * b];
      /* dgemm: http://tinyurl.com/j24npm4 */
      /* C <-- alpha * A * B + beta * C */
      cblas_dgemm (CblasRowMajor, CblasNoTrans, CblasTrans,
                   n,          /* m (n),    # rows of A (P) */
                   b,          /* n (b),    # cols of B (AT) (post-transpose) */
                   n,          /* k (n),    # cols of A (P) == rows of B (AT post-tranpose) */
                   1, P, n,    /* alpha, A, # cols A (P,  pre-transpose)*/
                   A, n,       /*        B, # cols B (AT, pre-transpose)*/
                   0, PAT, b); /* beta,  C, # cols C */
      printm ("P.AT", PAT, n, b);

      /*
       ,*       D      =         A     .    PAT    +     Z
       ,*       b                n           b           b
       ,*  b / * * \      b / * * * * \ n / * * \ + b / * * \
       ,*    \ * * /  <--   \ * * * * /   | * * |     \ * * /
       ,*                                 | * * |
       ,*                                 \ * * /
       ,*
       ,*/

      double D[b * b];
      /* D <- A.PAT + Z (copy Z to D first) */
      cblas_dcopy (b * b, Z, 1, D, 1);
      /* dgemm: http://tinyurl.com/j24npm4 */
      /* C <-- alpha * A * B + beta * C */
      cblas_dgemm (CblasRowMajor, CblasNoTrans, CblasNoTrans,
                   b,          /* m (b),          # rows of A (A) */
                   b,          /* n (b),          # cols of B (PAT) */
                   n,          /* k (n),          # cols of A (A) == rows of B (PAT) */
                   1, A, n,    /* alpha, A (A),   # cols A (A) */
                   PAT, b,     /*        B (PAT), # cols B (PAT)*/
                   1, D, b);   /* beta,  C (Z),   # cols C (D) */
      printm ("D", D, b, b);

      /*
       ,*     Res  =  alpha * A    .     x + beta * z
       ,*      1              n          1          1
       ,*  b / * \     b / * * * * \ n / * \ +  b / * \
       ,*    \ * /  <--  \ * * * * /   | * |      \ * /
       ,*                              | * |
       ,*                              \ * /
       ,*
       ,*/
      double Res[b * 1];
      /* Res <- (-A.x) + z (copy z to Res first)  */
      cblas_dcopy (b * 1, z, 1, Res, 1);
      /* dgemm: http://tinyurl.com/j24npm4 */
      /* C <-- alpha * A * B + beta * C */
      cblas_dgemm (CblasRowMajor, CblasNoTrans, CblasNoTrans,
                   b,          /* m (b),        # rows of A (A) */
                   1,          /* n (1),        # cols of B (x) */
                   n,          /* k (n),        # cols of A (A) == rows of B (x) */
                   -1, A, n,   /* alpha, A (A), # cols A (A) */
                   x, 1,       /*        B (x), # cols B (x) */
                   1, Res, 1); /* beta,  C (z), # cols C (Res) */
      printm ("Res", Res, b, 1);

      /*
       ,*    DiRes  = (Di = D^-1) . Res
       ,*      1            b        1
       ,*  b / * \     b / * * \ b / * \
       ,*    \ * /  <--  \ * * /   \ * /
       ,*
       ,*/

      double DiRes[b * 1];
      double DCholesky[b * b];
      /* DiRes = LinearSolve[D, z - A.x];    (* b x 1 *) */
      /* copy Res to DiRes, first. */
      /* copy D to DCholesky first. */
      /* dposv: http://goo.gl/O7gUH8 */
      cblas_dcopy (b * 1, Res, 1, DiRes,     1);
      cblas_dcopy (b * b, D,   1, DCholesky, 1);
      int result = LAPACKE_dposv (LAPACK_ROW_MAJOR, 'U',
                                  b,         /* NEQS: # rows of D */
                                  1,         /* NRHS: # columns of z - A.x == Res */
                                  DCholesky, /* DCholesky starts as D */
                                  b,         /* PDA D */
                                  DiRes,     /* output buffer */
                                  b);        /* PDA DiRes */
      printf ("DPOSV DiRes result %d\n\n", result);
      printm ("DiRes",     DiRes,     b, 1);
      printm ("DCholesky", DCholesky, b, b);

      /*
       ,*     KRes  =      PAT  .  DiRes
       ,*      1            b        1
       ,*  n / * \     n / * * \ b / * \
       ,*    | * |  <--  | * * |   \ * /
       ,*    | * |       | * * |
       ,*    \ * /       \ * * /
       ,*
       ,*/

      double KRes[n * 1];
      /* KRes <-- PAT.DiRes */
      /* dgemm: http://tinyurl.com/j24npm4 */
      /* C <-- alpha * A * B + beta * C */
      cblas_dgemm (CblasRowMajor, CblasNoTrans, CblasNoTrans,
                   n,           /* m (n),            # rows of A (PAT) */
                   1,           /* n (1),            # cols of B (DiRes) */
                   b,           /* k (b),            # cols of A (PAT) == # rows of B (DiRes) */
                   1, PAT, b,   /* alpha, A (PAT),   # cols A (PAT) */
                   DiRes, 1,    /*        B (DiRes), # cols B (DiRes) */
                   0, KRes, 1); /* beta,  C (KRes),  # cols C (KRes) */
      printm ("KRes", KRes, n, 1);

      /*
       ,*         AP      =         A      .      P
       ,*         n                 n             n
       ,*  b / * * * * \     b / * * * * \ n / * * * * \
       ,*    \ * * * * /  <--  \ * * * * /   | * * * * |
       ,*                                    | * * * * |
       ,*                                    \ * * * * /
       ,*
       ,*/

      double AP[b * n];
      /* AP <-- A.P */
      /* dgemm: http://tinyurl.com/j24npm4 */
      /* C <-- alpha * A * B + beta * C */
      cblas_dgemm (CblasRowMajor, CblasNoTrans, CblasNoTrans,
                   b,           /* m (b),          # rows of A (A) */
                   n,           /* n (n),          # cols of B (P) */
                   n,           /* k (n),          # cols of A (A) == # rows of B (P) */
                   1, A, n,     /* alpha, A (A),   # cols A (PAT) */
                   P, n,        /*        B (P),   # cols B (DiRes) */
                   0, AP, n);   /* beta,  C (AP),  # cols C (KRes) */
      printm ("AP", AP, b, n);

      /*
       ,*        DiAP    =    (Di = D^-1)  .  A      .      P
       ,*         n               b           n             n
       ,*  b / * * * * \     b / * * \ b / * * * * \ n / * * * * \
       ,*    \ * * * * /  <--  \ * * /   \ * * * * /   | * * * * |
       ,*                                              | * * * * |
       ,*                                              \ * * * * /
       ,*
       ,*/

      double DiAP[b * n];
      /* DiAP = LinearSolve[D, AP];    (* b x n *) */
      /* copy AP to DiAP, first. */
      /* copy D to DCholesky first. */
      /* dposv: http://goo.gl/O7gUH8 */
      cblas_dcopy (b * n, AP, 1, DiAP,      1);
      cblas_dcopy (b * b, D,  1, DCholesky, 1);
      result = LAPACKE_dposv (LAPACK_ROW_MAJOR, 'U',
                              b,         /* NEQS: # rows of D */
                              n,         /* NRHS: # columns of z - A.x == Res */
                              DCholesky, /* DCholesky starts as D */
                              b,         /* PDA D */
                              DiAP,      /* output buffer */
                              n);        /* PDA DiRes */
      printf ("DPOSV DiAP result %d\n\n", result);
      printm ("DiAP",      DiAP,      b, n);
      printm ("DCholesky", DCholesky, b, b);

      /*
       ,*        KAP      =      PAT    .    DiAP
       ,*         n               b           n
       ,*  n / * * * * \     n / * * \ b / * * * * \
       ,*    | * * * * |  <--  | * * |   \ * * * * /
       ,*    | * * * * |       | * * |
       ,*    \ * * * * /       \ * * /
       ,*
       ,*/

      double KAP[n * n];
      /* KAP <-- PAT.DiAP */
      /* dgemm: http://tinyurl.com/j24npm4 */
      /* C <-- alpha * A * B + beta * C */
      cblas_dgemm (CblasRowMajor, CblasNoTrans, CblasNoTrans,
                   n,             /* m (n),           # rows of A (PAT) */
                   n,             /* n (n),           # cols of B (DiAP) */
                   b,             /* k (b),           # cols of A (PAT) == # rows of B (DiAP) */
                   1, PAT, b,     /* alpha, A (PAT),  # cols A (PAT) */
                   DiAP, n,       /*        B (Diap), # cols B (DiRes) */
                   0, KAP, n);    /* beta,  C (KAP),  # cols C (KAP) */
      printm ("KAP", KAP, n, n);

      /*
       ,*      x  =  alpha * Id     .    x   +    KRes
       ,*      1              n          1         1
       ,*  n / * \     n / * * * * \ n / * \ + n / * \
       ,*    | * |  <--  | * * * * |   | * |     | * |
       ,*    | * |       | * * * * |   | * |     | * |
       ,*    \ * /       \ * * * * /   \ * /     \ * /
       ,*
       ,*/

      /* x <-- alpha * IdN[n] * KRes + beta * x */
      /* dgemm: http://tinyurl.com/j24npm4 */
      /* C <-- alpha * A * B + beta * C */
      cblas_dgemm (CblasRowMajor, CblasNoTrans, CblasNoTrans,
                   n,           /* m (n),           # rows of A (Id) */
                   1,           /* n (1),           # cols of B (x) */
                   n,           /* k (n),           # cols of A (Id) == rows of B (x) */
                   1, IdN, n,   /* alpha, A (Id),   # cols A */
                   x, 1,        /*        B (x),    # cols B */
                   1, KRes, 1); /* beta,  C (Kres), # cols C (new x) */
      cblas_dcopy (n * 1, KRes, 1, x, 1);
      printm ("x", x, n, 1);

      /*
       ,*         P    =   alpha * Id      .     KAP    +  beta * P
       ,*         n                 n             n               n
       ,*  n / * * * * \     n / * * * * \ n / * * * * \ + n / * * * * \
       ,*    | * * * * |  <--  | * * * * |   | * * * * |     | * * * * |
       ,*    | * * * * |       | * * * * |   | * * * * |     | * * * * |
       ,*    \ * * * * /       \ * * * * /   \ * * * * /     \ * * * * /
       ,*
       ,*/

      /* P <-- P - KAP == - IdN[n] * KAP  + P */
      /* dgemm: http://tinyurl.com/j24npm4 */
      /* C <-- alpha * A * B + beta * C */
      cblas_dgemm (CblasRowMajor, CblasNoTrans, CblasNoTrans,
                   n,           /* m (n),         # rows of A (Id) */
                   n,           /* n (n),         # cols of B (KAP) */
                   n,           /* k (n),         # cols of A (Id) == rows of B (KAP) */
                   -1, IdN, n,  /* alpha, A (Id), # cols A */
                   KAP, n,      /*        B (x),  # cols B */
                   1, P, n);    /* beta,  C (P),  # cols C (new P) */
      printm ("P", P, n, n); }

  int main (int argc, char ** argv)
  {   const int    b = 1;
      const int    n = 4;

      double IdN[n * n] = { 1., 0., 0., 0.,
                            0., 1., 0., 0.,
                            0., 0., 1., 0.,
                            0., 0., 0., 1. };


      double Z[b * b] = {1.};

      double x[n * 1] = {0., 0., 0., 0};
      double P[n * n] = {1000.,    0.,    0.,    0.,
                         0., 1000.,    0.,    0.,
                         0.,    0., 1000.,    0.,
                         0.,    0.,    0., 1000. };

      double A[b * n] = {1., 0., 0., 0};
      double z[b] = {-2.28442};

      kalman (b, n, IdN, Z, x, P, A, z);

      A[0] = 1;
      A[1] = 1;
      A[2] = 1;
      A[3] = 1;

      z[0] = -4.83168;

      kalman (b, n, IdN, Z, x, P, A, z);

      A[0] = 1;
      A[1] = -1;
      A[2] = 1;
      A[3] = -1;

      z[0] = -10.4601;

      kalman (b, n, IdN, Z, x, P, A, z);

      A[0] = 1;
      A[1] = -2;
      A[2] = 4;
      A[3] = -8;

      z[0] = 1.40488;

      kalman (b, n, IdN, Z, x, P, A, z);

      A[0] = 1;
      A[1] = 2;
      A[2] = 4;
      A[3] = 8;

      z[0] = -40.8079;

      kalman (b, n, IdN, Z, x, P, A, z);

      return 0;   }
#+END_SRC

#+BEGIN_SRC bash
gcc qux.c -lcblas -llapacke -llapack
./a.out
#+END_SRC

#+RESULTS:
|         P.AT |              |              |              |
|         1000 |              |              |              |
|            0 |              |              |              |
|            0 |              |              |              |
|            0 |              |              |              |
|              |              |              |              |
|            D |              |              |              |
|         1001 |              |              |              |
|              |              |              |              |
|          Res |              |              |              |
|     -2.28442 |              |              |              |
|              |              |              |              |
|        DPOSV |        DiRes |       result |            0 |
|              |              |              |              |
|        DiRes |              |              |              |
|  -0.00228214 |              |              |              |
|              |              |              |              |
|    DCholesky |              |              |              |
|      31.6386 |              |              |              |
|              |              |              |              |
|         KRes |              |              |              |
|     -2.28214 |              |              |              |
|            0 |              |              |              |
|            0 |              |              |              |
|            0 |              |              |              |
|              |              |              |              |
|           AP |              |              |              |
|         1000 |            0 |            0 |            0 |
|              |              |              |              |
|        DPOSV |         DiAP |       result |            0 |
|              |              |              |              |
|         DiAP |              |              |              |
|     0.999001 |            0 |            0 |            0 |
|              |              |              |              |
|    DCholesky |              |              |              |
|      31.6386 |              |              |              |
|              |              |              |              |
|          KAP |              |              |              |
|      999.001 |            0 |            0 |            0 |
|            0 |            0 |            0 |            0 |
|            0 |            0 |            0 |            0 |
|            0 |            0 |            0 |            0 |
|              |              |              |              |
|            x |              |              |              |
|     -2.28214 |              |              |              |
|            0 |              |              |              |
|            0 |              |              |              |
|            0 |              |              |              |
|              |              |              |              |
|            P |              |              |              |
|     0.999001 |            0 |            0 |            0 |
|            0 |         1000 |            0 |            0 |
|            0 |            0 |         1000 |            0 |
|            0 |            0 |            0 |         1000 |
|              |              |              |              |
|         P.AT |              |              |              |
|     0.999001 |              |              |              |
|         1000 |              |              |              |
|         1000 |              |              |              |
|         1000 |              |              |              |
|              |              |              |              |
|            D |              |              |              |
|         3002 |              |              |              |
|              |              |              |              |
|          Res |              |              |              |
|     -2.54954 |              |              |              |
|              |              |              |              |
|        DPOSV |        DiRes |       result |            0 |
|              |              |              |              |
|        DiRes |              |              |              |
| -0.000849281 |              |              |              |
|              |              |              |              |
|    DCholesky |              |              |              |
|      54.7905 |              |              |              |
|              |              |              |              |
|         KRes |              |              |              |
| -0.000848433 |              |              |              |
|    -0.849281 |              |              |              |
|    -0.849281 |              |              |              |
|    -0.849281 |              |              |              |
|              |              |              |              |
|           AP |              |              |              |
|     0.999001 |         1000 |         1000 |         1000 |
|              |              |              |              |
|        DPOSV |         DiAP |       result |            0 |
|              |              |              |              |
|         DiAP |              |              |              |
|  0.000332779 |     0.333111 |     0.333111 |     0.333111 |
|              |              |              |              |
|    DCholesky |              |              |              |
|      54.7905 |              |              |              |
|              |              |              |              |
|          KAP |              |              |              |
|  0.000332446 |     0.332779 |     0.332779 |     0.332779 |
|     0.332779 |      333.111 |      333.111 |      333.111 |
|     0.332779 |      333.111 |      333.111 |      333.111 |
|     0.332779 |      333.111 |      333.111 |      333.111 |
|              |              |              |              |
|            x |              |              |              |
|     -2.28299 |              |              |              |
|    -0.849281 |              |              |              |
|    -0.849281 |              |              |              |
|    -0.849281 |              |              |              |
|              |              |              |              |
|            P |              |              |              |
|     0.998669 |    -0.332779 |    -0.332779 |    -0.332779 |
|    -0.332779 |      666.889 |     -333.111 |     -333.111 |
|    -0.332779 |     -333.111 |      666.889 |     -333.111 |
|    -0.332779 |     -333.111 |     -333.111 |      666.889 |
|              |              |              |              |
|         P.AT |              |              |              |
|      1.33145 |              |              |              |
|     -667.221 |              |              |              |
|      1332.78 |              |              |              |
|     -667.221 |              |              |              |
|              |              |              |              |
|            D |              |              |              |
|      2669.55 |              |              |              |
|              |              |              |              |
|          Res |              |              |              |
|      -9.0264 |              |              |              |
|              |              |              |              |
|        DPOSV |        DiRes |       result |            0 |
|              |              |              |              |
|        DiRes |              |              |              |
|  -0.00338124 |              |              |              |
|              |              |              |              |
|    DCholesky |              |              |              |
|      51.6677 |              |              |              |
|              |              |              |              |
|         KRes |              |              |              |
|  -0.00450194 |              |              |              |
|      2.25603 |              |              |              |
|     -4.50644 |              |              |              |
|      2.25603 |              |              |              |
|              |              |              |              |
|           AP |              |              |              |
|      1.33145 |     -667.221 |      1332.78 |     -667.221 |
|              |              |              |              |
|        DPOSV |         DiAP |       result |            0 |
|              |              |              |              |
|         DiAP |              |              |              |
|  0.000498753 |    -0.249938 |     0.499252 |    -0.249938 |
|              |              |              |              |
|    DCholesky |              |              |              |
|      51.6677 |              |              |              |
|              |              |              |              |
|          KAP |              |              |              |
|  0.000664063 |    -0.332779 |     0.664727 |    -0.332779 |
|    -0.332779 |      166.764 |     -333.111 |      166.764 |
|     0.664727 |     -333.111 |      665.392 |     -333.111 |
|    -0.332779 |      166.764 |     -333.111 |      166.764 |
|              |              |              |              |
|            x |              |              |              |
|     -2.28749 |              |              |              |
|      1.40675 |              |              |              |
|     -5.35572 |              |              |              |
|      1.40675 |              |              |              |
|              |              |              |              |
|            P |              |              |              |
|     0.998004 | -1.11022e-16 |    -0.997506 | -1.11022e-16 |
| -1.11022e-16 |      500.125 | -1.13687e-13 |     -499.875 |
|    -0.997506 | -5.68434e-14 |      1.49676 | -5.68434e-14 |
| -1.11022e-16 |     -499.875 | -1.13687e-13 |      500.125 |
|              |              |              |              |
|         P.AT |              |              |              |
|     -2.99202 |              |              |              |
|      2998.75 |              |              |              |
|      4.98952 |              |              |              |
|     -3001.25 |              |              |              |
|              |              |              |              |
|            D |              |              |              |
|      18030.5 |              |              |              |
|              |              |              |              |
|          Res |              |              |              |
|      39.1828 |              |              |              |
|              |              |              |              |
|        DPOSV |        DiRes |       result |            0 |
|              |              |              |              |
|        DiRes |              |              |              |
|   0.00217314 |              |              |              |
|              |              |              |              |
|    DCholesky |              |              |              |
|      134.278 |              |              |              |
|              |              |              |              |
|         KRes |              |              |              |
|  -0.00650209 |              |              |              |
|      6.51672 |              |              |              |
|     0.010843 |              |              |              |
|     -6.52215 |              |              |              |
|              |              |              |              |
|           AP |              |              |              |
|     -2.99202 |      2998.75 |      4.98952 |     -3001.25 |
|              |              |              |              |
|        DPOSV |         DiAP |       result |            0 |
|              |              |              |              |
|         DiAP |              |              |              |
| -0.000165942 |     0.166316 |  0.000276727 |    -0.166454 |
|              |              |              |              |
|    DCholesky |              |              |              |
|      134.278 |              |              |              |
|              |              |              |              |
|          KAP |              |              |              |
|  0.000496503 |     -0.49762 | -0.000827974 |     0.498035 |
|     -0.49762 |      498.739 |     0.829836 |     -499.155 |
| -0.000827974 |     0.829836 |   0.00138074 |    -0.830528 |
|     0.498035 |     -499.155 |    -0.830528 |      499.571 |
|              |              |              |              |
|            x |              |              |              |
|     -2.29399 |              |              |              |
|      7.92347 |              |              |              |
|     -5.34488 |              |              |              |
|      -5.1154 |              |              |              |
|              |              |              |              |
|            P |              |              |              |
|     0.997508 |      0.49762 |    -0.996678 |    -0.498035 |
|      0.49762 |       1.3855 |    -0.829836 |    -0.719881 |
|    -0.996678 |    -0.829836 |      1.49538 |     0.830528 |
|    -0.498035 |    -0.719881 |     0.830528 |     0.553787 |
|              |              |              |              |
|         P.AT |              |              |              |
|     -5.97824 |              |              |              |
|     -5.80977 |              |              |              |
|      9.96938 |              |              |              |
|      5.81461 |              |              |              |
|              |              |              |              |
|            D |              |              |              |
|      69.7966 |              |              |              |
|              |              |              |              |
|          Res |              |              |              |
|      7.94184 |              |              |              |
|              |              |              |              |
|        DPOSV |        DiRes |       result |            0 |
|              |              |              |              |
|        DiRes |              |              |              |
|     0.113785 |              |              |              |
|              |              |              |              |
|    DCholesky |              |              |              |
|      8.35444 |              |              |              |
|              |              |              |              |
|         KRes |              |              |              |
|    -0.680236 |              |              |              |
|    -0.661067 |              |              |              |
|      1.13437 |              |              |              |
|     0.661618 |              |              |              |
|              |              |              |              |
|           AP |              |              |              |
|     -5.97824 |     -5.80977 |      9.96938 |      5.81461 |
|              |              |              |              |
|        DPOSV |         DiAP |       result |            0 |
|              |              |              |              |
|         DiAP |              |              |              |
|   -0.0856523 |   -0.0832385 |     0.142835 |    0.0833079 |
|              |              |              |              |
|    DCholesky |              |              |              |
|      8.35444 |              |              |              |
|              |              |              |              |
|          KAP |              |              |              |
|      0.51205 |      0.49762 |      -0.8539 |    -0.498035 |
|      0.49762 |     0.483596 |    -0.829836 |       -0.484 |
|      -0.8539 |    -0.829836 |      1.42397 |     0.830528 |
|    -0.498035 |       -0.484 |     0.830528 |     0.484403 |
|              |              |              |              |
|            x |              |              |              |
|     -2.97423 |              |              |              |
|       7.2624 |              |              |              |
|     -4.21051 |              |              |              |
|     -4.45378 |              |              |              |
|              |              |              |              |
|            P |              |              |              |
|     0.485458 | -1.07747e-13 |    -0.142778 |  5.32907e-14 |
| -2.76612e-13 |     0.901908 |  1.57763e-13 |    -0.235882 |
|    -0.142778 |  2.77556e-14 |    0.0714031 | -5.08482e-14 |
|  9.55347e-14 |    -0.235882 | -8.32667e-14 |    0.0693839 |
|              |              |              |              |

*** COMMENT Another Example

From http://tinyurl.com/hun752f.

#+BEGIN_SRC C :includes '(<stdio.h> <stdlib.h> <string.h> <cblas.h>) :flags -lcblas :exports both
  /* 3x3 A matrix (symmetric) */
  double a[] = {1,2,6,
                2,3,1,
                6,1,4};
  /* 3x2 B Matrix */
  double b[] = {2,3,
                4,5,
                6,7};
  /* 3x2 C Matrix */
  double c[] = {0,0,
                0,0,
                0,0};

  /* Let's define the SYMM paramaters in terms
   ,* of row count and coloumn count of C */
  int m = 3;
  int n = 2;

  double alpha = 1.0;
  double beta  = 0.0;

  enum CBLAS_ORDER ord  = CblasRowMajor;
  enum CBLAS_SIDE  side = CblasLeft;
  enum CBLAS_UPLO  uplo = CblasUpper;

  /* The leading dimension for A, B and C are set considering
   ,* row-major format.
   ,*
   ,* For this particular example:
   ,* lda = # of columns A (or rows since A is symmetric)
   ,* ldb = # of columns B, i.e., # entries in a row
   ,* ldc = # of columns C, i.e., # entries in a row */

  void cblas_dsymm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side,
                   const enum CBLAS_UPLO Uplo, const int M, const int N,
                   const double alpha, const double *A, const int lda,
                   const double *B, const int ldb, const double beta,
                   double *C, const int ldc);

  cblas_dsymm( ord, side, uplo,
               m, n,
               alpha, a, m,
               b, n, beta,
               c, n );

  /* This should print 46 55 22 28 40 51 */
  for(int z=0;z<6;z++)
      printf ("%g ", c[z]);
#+END_SRC

#+RESULTS:
: 46 55 22 28 40 51

#+BEGIN_SRC C :tangle bar.c
  #include <stdio.h>

  void print_RMO_matrix (double * M, int n_rows, int n_cols) {
      for (int row = 0; row < n_rows; ++row)
      {   for (int col = 0; col < n_cols; ++col)
          {   printf ("%g", M[col + n_cols * row]);
              if (n_cols-1 != col)
              {   printf (", ");   }   }
          if (n_rows-1 != row)
          {   printf ("\n");   }   }
      printf ("\n\n");   }

  void print_CMO_matrix (double * M, int n_rows, int n_cols) {
      for (int row = 0; row < n_rows; ++row)
      {   for (int col = 0; col < n_cols; ++col)
          {   printf ("%g", M[row + n_rows * col]);
              if (n_cols-1 != col)
              {   printf (", ");   }   }
          if (n_rows-1 != row)
          {   printf ("\n");   }   }
      printf ("\n\n");   }

  int main (int argc, char ** argv) {
      int N = 3;
      int M = 3;
      int MN = 3 * 3;
      /* The following input appears in row-major order. The underlying fortran
         code 'sees' the transpose of this matrix, i.e., the same data in
         column-major order. Although this is the matrix A for fortran from our
         example, it looks, in C, like AT.

         BLAS does not include a high-performance matrix transpose routine. */

      double A[4][5] = { { 1.,  1.,  1.,  1.,  1.},
                         { 0.,  1., -1., -2.,  2.},
                         { 0.,  1.,  1.,  4.,  4.},
                         { 0.,  1., -1., -8.,  8.}};

      double DX[3][3] = { {1 , 2 ,  3},
                          {4 , 5 ,  6},
                          {7 , 8 , 19} };
      double DY[3][3] = { {0 , 0 ,  0},
                          {0 , 0 ,  0},
                          {0 , 0 ,  0} };

      print_RMO_matrix ((double *)A, 4, 5);
      print_CMO_matrix ((double *)A, 5, 4);

      int INCX = 1;
      int INCY = 1;
      /* from http://www.netlib.org/lapack/explore-html/da/d6c/dcopy_8f_source.html
         SUBROUTINE dcopy(N,DX,INCX,DY,INCY)
         ,*
         ,*  -- Reference BLAS level1 routine (version 3.4.0) --
         ,*  -- Reference BLAS is a software package provided by Univ. of Tennessee,    --
         ,*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
         ,*     November 2011
         ,*
         ,*     .. Scalar Arguments ..
         INTEGER INCX,INCY,N
         ,*     ..
         ,*     .. Array Arguments ..
         DOUBLE PRECISION DX(*),DY(*)
         ,*     ..
         ,*/

      extern void dcopy_ (int * N, double * DX, int * INCX, double * DY, int * INCY);

      print_RMO_matrix ((double *)DX, N, N);
      print_RMO_matrix ((double *)DY, N, N);

      dcopy_ (&MN, DX[0], &INCX, DY[0], &INCY);

      print_RMO_matrix ((double *)DX, N, N);
      print_RMO_matrix ((double *)DY, N, N);   }
#+END_SRC

Tangle it to =bar.c=, then compile and run as follows:

#+BEGIN_SRC bash
gcc bar.c -lblas && ./a.out
#+END_SRC

#+RESULTS:
| 1 |  1 |  1 |  1 | 1 |
| 0 |  1 | -1 | -2 | 2 |
| 0 |  1 |  1 |  4 | 4 |
| 0 |  1 | -1 | -8 | 8 |
|   |    |    |    |   |
| 1 |  0 |  0 |  0 |   |
| 1 |  1 |  1 |  1 |   |
| 1 | -1 |  1 | -1 |   |
| 1 | -2 |  4 | -8 |   |
| 1 |  2 |  4 |  8 |   |
|   |    |    |    |   |
| 1 |  2 |  3 |    |   |
| 4 |  5 |  6 |    |   |
| 7 |  8 | 19 |    |   |
|   |    |    |    |   |
| 0 |  0 |  0 |    |   |
| 0 |  0 |  0 |    |   |
| 0 |  0 |  0 |    |   |
|   |    |    |    |   |
| 1 |  2 |  3 |    |   |
| 4 |  5 |  6 |    |   |
| 7 |  8 | 19 |    |   |
|   |    |    |    |   |
| 1 |  2 |  3 |    |   |
| 4 |  5 |  6 |    |   |
| 7 |  8 | 19 |    |   |

* Footnotes


[fn:affn] https://en.wikipedia.org/wiki/Affine_transformation
[fn:babl] http://orgmode.org/worg/org-contrib/babel/
[fn:bars] Bar-Shalom, Yaakov, /et al/. Estimation with applications to tracking and navigation. New York: Wiley, 2001.
[fn:bier] http://tinyurl.com/h3jh4kt
[fn:blas] http://www.netlib.org/blas/
[fn:blck] http://tinyurl.com/bgwfkyc
[fn:bssl] https://en.wikipedia.org/wiki/Bessel's_correction
[fn:busi] https://en.wikipedia.org/wiki/Business_logic
[fn:cbls] http://www.netlib.org/blas/
[fn:cdot] We sometimes use the center dot or the $\times$ symbols to clarify matrix multiplication. They have no other significance and we can always write matrix multiplication just by juxtaposing the matrices.
[fn:clos] https://en.wikipedia.org/wiki/Closure_(computer_programming)
[fn:cold] This convention only models so-called /cold observables/, but it's enough to demonstrate Kalman's working over them.
[fn:cons] This is quite similar to the standard --- not  Wolfram's --- definition of a list as a pair of a value and of another list.
[fn:cova] We use the terms /covariance/ for matrices and /variance/ for scalars.
[fn:csoc] https://en.wikipedia.org/wiki/Separation_of_concerns
[fn:ctsc] https://en.wikipedia.org/wiki/Catastrophic_cancellation
[fn:ditm] Cook, John D. /Don't invert that matrix/ http://tinyurl.com/ya4q2kv
[fn:dpos] http://www.nag.com/numeric/FL/manual/pdf/F07/f07faf.pdf
[fn:doxy] http://www.stack.nl/~dimitri/doxygen/
[fn:dstr] http://tinyurl.com/ze6qfb3
[fn:dtaa] http://tinyurl.com/cwcdwq8
[fn:eclx] https://gitlab.com/embeddable-common-lisp/ecl/wikis/home
[fn:elib] Brookner, Eli. Tracking and Kalman Filtering Made Easy, New York: Wiley, 1998. http://tinyurl.com/h8see8k
[fn:fldl] http://tinyurl.com/jmxsevr
[fn:fncc] http://blog.madhukaraphatak.com/functional-programming-in-c++/
[fn:fwik] https://en.wikipedia.org/wiki/Fold_%28higher-order_function%29
[fn:gama] https://en.wikipedia.org/wiki/Gauss%E2%80%93Markov_theorem
[fn:gibb] Bruce P. Gibbs, /Advanced Kalman Filtering, Least-Squares and Modeling/, New York: Wiley, 2011.
[fn:gslb] http://www.gnu.org/software/gsl/
[fn:gtst] https://code.google.com/p/googletest/
[fn:intr] http://introtorx.com/
[fn:ipyt] http://ipython.org/
[fn:jass] http://www.jstatsoft.org/v46/i03
[fn:javd] http://tinyurl.com/o424429
[fn:jplg] JPL Geodynamics Program http://www.jpl.nasa.gov/report/1981.pdf
[fn:just] justified by the fact that $\mathbold{D}$ is a diagonal matrix that commutes with all other products, therefore its left and right inverses are equal and can be written as a reciprocal; in fact, $\mathbold{D}$ is a $1\times{1}$ matrix --- effectively a scalar --- in all examples in this paper
[fn:klde] B. Beckman, /Kalman Folding 3: Derivations/, to appear.
[fn:klf1] B. Beckman, /Kalman Folding, Part 1/, to appear.
[fn:klf2] B. Beckman, /Kalman Folding 2: Tracking and System Dynamics/, to appear.
[fn:klf3] B. Beckman, /Kalman Folding 3: Derivations/, to appear.
[fn:klf4] B. Beckman, /Kalman Folding 4: Streams and Observables/, to appear.
[fn:klf5] B. Beckman, /Kalman Folding 5: Non-Linear Models and the EKF/, to appear.
[fn:klf7] B. Beckman, /Kalman Folding 7: A Small Streams Library/, to appear.
[fn:klf9] B. Beckman, /Kalman Folding 9: in C/, to appear.
[fn:klfl] B. Beckman, /Kalman Folding, Part 1/, to appear.
[fn:kohl] https://chriskohlhepp.wordpress.com/embedding-lisp-in-cplusplus-a-recipe/
[fn:lavl] http://vgoulet.act.ulaval.ca/en/emacs/
[fn:layi] https://en.wikipedia.org/wiki/Fundamental_theorem_of_software_engineering
[fn:litp] https://en.wikipedia.org/wiki/Literate_programming
[fn:lmbd] Many languages use the keyword /lambda/ for such expressions; Wolfram uses the name /Function/.
[fn:lmlf] https://en.wikipedia.org/wiki/Lambda_lifting
[fn:lpck] http://www.netlib.org/lapack/
[fn:lpke] http://www.netlib.org/lapack/lapacke.html
[fn:lsqo] LINQ's Standard Query Operators
[fn:lssq] https://en.wikipedia.org/wiki/Least_squares
[fn:ltis] http://tinyurl.com/hhhcgca
[fn:matt] https://www.cs.kent.ac.uk/people/staff/dat/miranda/whyfp90.pdf
[fn:mcmc] https://en.wikipedia.org/wiki/Particle_filter
[fn:mond] https://en.wikipedia.org/wiki/Monad
[fn:mrck] https://gist.github.com/mrocklin/5144149
[fn:musc] http://www1.cs.dartmouth.edu/~doug/music.ps.gz
[fn:ndim] https://en.wikipedia.org/wiki/Nondimensionalization
[fn:ndoc] http://www.nag.com/numeric/CL/CLdocumentation.asp
[fn:obc1] Make sure the first example from http://tinyurl.com/kz2lz7m works
[fn:orgm] https://en.wikipedia.org/wiki/Org-mode
[fn:patt] http://tinyurl.com/j5jzy69
[fn:pico] http://tinyurl.com/gku2k74
[fn:plnt] http://plantuml.com/emacs.html
[fn:pseu] http://tinyurl.com/j8gvlug
[fn:rasp] http://www.wolfram.com/raspberry-pi/
[fn:rcrn] https://en.wikipedia.org/wiki/Recurrence_relation
[fn:root] https://root.cern.ch/root-user-guides-and-manuals
[fn:rprs] https://www.coursera.org/learn/reproducible-research
[fn:rsfr] http://rosettacode.org/wiki/Loops/Foreach
[fn:rxbk] http://www.introtorx.com/content/v1.0.10621.0/07_Aggregation.html
[fn:sage] http://www.sagemath.org/
[fn:scan] and of Haskell's scans and folds, and Rx's scans and folds, /etc./
[fn:scla] http://tinyurl.com/hhdot36
[fn:scnd] A state-space form containing a position and derivative is commonplace in second-order dynamics like Newton's Second Law. We usually employ state-space form to reduce \(n\)-th-order differential equations to first-order differential equations by stacking the dependent variable on $n-1$ of its derivatives in the state vector.
[fn:scnl] http://learnyouahaskell.com/higher-order-functions
[fn:scp1] https://en.wikipedia.org/wiki/Scripting_language
[fn:scp2] http://tinyurl.com/mj3n9aq
[fn:scp3] http://tinyurl.com/3tunry3
[fn:siod] http://tinyurl.com/o5jx6xr
[fn:spac] https://github.com/syl20bnr/spacemacs
[fn:spcm] http://www.spacemacs.org
[fn:stsp] https://en.wikipedia.org/wiki/State-space_representation
[fn:tikz] http://tinyurl.com/juw7524
[fn:trak] B. Beckman, /Kalman Folding 2: Tracking and System Dynamics/, To appear.
[fn:uncl] The initial uncial (lower-case) letter signifies that /we/ wrote this function; it wasn't supplied by Wolfram.
[fn:wfld] http://reference.wolfram.com/language/ref/FoldList.html?q=FoldList
[fn:wlf1] http://tinyurl.com/nfz9fyo
[fn:wlf2] http://rebcabin.github.io/blog/2013/02/04/welfords-better-formula/
[fn:wolf] http://reference.wolfram.com/language/
[fn:zarc] Zarchan and Musoff, /Fundamentals of Kalman Filtering, A Practical Approach, Fourth Edition/, Ch. 4
