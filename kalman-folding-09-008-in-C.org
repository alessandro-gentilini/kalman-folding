#+TITLE: Kalman Folding 9: in C (WORKING DRAFT)
#+SUBTITLE: Extracting Models from Data, One Observation at a Time
#+AUTHOR: Brian Beckman
#+DATE: <2016-05-17 Tue>
#+EMAIL: bbeckman@34363bc84acc.ant.amazon.com
#+OPTIONS: ':t *:t -:t ::t <:t H:3 \n:nil ^:t arch:headline author:t c:nil
#+OPTIONS: creator:comment d:(not "LOGBOOK") date:t e:t email:nil f:t inline:t
#+OPTIONS: num:t p:nil pri:nil stat:t tags:t tasks:t tex:t timestamp:t toc:t
#+OPTIONS: todo:t |:t
#+SELECT_TAGS: export
#+STARTUP: indent
#+LaTeX_CLASS_OPTIONS: [10pt,oneside,x11names]
#+LaTeX_HEADER: \usepackage{geometry}
#+LaTeX_HEADER: \usepackage{amsmath}
#+LaTeX_HEADER: \usepackage{amssymb}
#+LaTeX_HEADER: \usepackage{amsfonts}
#+LaTeX_HEADER: \usepackage{palatino}
#+LaTeX_HEADER: \usepackage{siunitx}
#+LaTeX_HEADER: \usepackage{esdiff}
#+LaTeX_HEADER: \usepackage{xfrac}
#+LaTeX_HEADER: \usepackage{nicefrac}
#+LaTeX_HEADER: \usepackage{faktor}
#+LaTeX_HEADER: \usepackage[euler-digits,euler-hat-accent]{eulervm}
#+OPTIONS: toc:2

* COMMENT Preliminaries

This section is just about setting up org-mode. It shouldn't export to the
typeset PDF and HTML.

#+BEGIN_SRC emacs-lisp :exports results none
  (defun update-equation-tag ()
    (interactive)
    (save-excursion
      (goto-char (point-min))
      (let ((count 1))
        (while (re-search-forward "\\tag{\\([0-9]+\\)}" nil t)
          (replace-match (format "%d" count) nil nil nil 1)
          (setq count (1+ count))))))
  (update-equation-tag)
  (setq org-confirm-babel-evaluate nil)
  ; (org-babel-map-src-blocks nil (org-babel-remove-result))
  ; (slime)
#+END_SRC

#+RESULTS:
: #<buffer *inferior-lisp*>

* COMMENT Abstract

In /Kalman Folding, Part 1/,[fn:klf1] we present basic, static Kalman filtering
as a functional fold, highlighting the unique advantages of this form for
deploying test-hardened code verbatim in harsh, mission-critical environments.
In that paper, all examples folded over arrays in memory for convenience and
repeatability. That is an example of developing filters in a friendly
environment.

Here, we prototype a couple of less friendly environments and demonstrate
exactly the same Kalman accumulator function at work. These less friendly
environments are
- lazy streams, where new observations are computed on demand but never fully
  realized in memory, thus not available for inspection in a debugger
- asynchronous observables, where new observations are delivered at arbitrary
  times from an external source, thus not available for replay once consumed by
  the filter

Streams are a natural fit for integration of differential equations, which often
arise in applications. As such, they enable unique modularization for all kinds
of filters, including non-linear Extended Kalman Filters.

The fact that the Kalman accumulator function gives bit-for-bit identical
results in all cases gives us high confidence that code developed in friendly
environments will behave as intended in unfriendly environments. This level of
repeatability is available /only/ because of functional decomposition, which
minimizes the coupling between the accumulator function and the environment and
makes it possible to deploy exactly the same code, without even recompilation,
in all environments.

* COMMENT Kalman Folding in the Wolfram Language

In this series of papers, we use the Wolfram language[fn:wolf] because it excels
at concise expression of mathematical code. All examples in these papers can be
directly transcribed to any modern mainstream language that supports closures.
For example, it is easy to write them in C++11 and beyond, Python, any modern
Lisp, not to mention Haskell, Scala, Erlang, and OCaml. Many can be written
without full closures; function pointers will suffice, so they are easy to write
in C. It's also not difficult to add extra arguments to simulate just enough
closure-like support in C to write the rest of the examples in that language.


In /Kalman Folding/,[fn:klfl] we found the following elegant formulation for the
accumulator function of a fold that implements the static Kalman filter:

#+BEGIN_LaTeX
\begin{equation}
\label{eqn:kalman-cume-definition}
\text{kalmanStatic}
\left(
\mathbold{Z}
\right)
\left(
\left\{
\mathbold{x},
\mathbold{P}
\right\},
\left\{
\mathbold{A},
\mathbold{z}
\right\}
\right) =
\left\{
\mathbold{x}+
\mathbold{K}\,
\left(
\mathbold{z}-
\mathbold{A}\,
\mathbold{x}
\right),
\mathbold{P}-
\mathbold{K}\,
\mathbold{D}\,
\mathbold{K}^\intercal
\right\}
\end{equation}
#+END_LaTeX

\noindent where

#+BEGIN_LaTeX
\begin{align}
\label{eqn:kalman-gain-definition}
\mathbold{K}
&=
\mathbold{P}\,
\mathbold{A}^\intercal\,
\mathbold{D}^{-1} \\
\label{eqn:kalman-denominator-definition}
\mathbold{D}
&= \mathbold{Z} +
\mathbold{A}\,
\mathbold{P}\,
\mathbold{A}^\intercal
\end{align}
#+END_LaTeX

\noindent and all quantities are matrices:

- $\mathbold{z}$ is a  ${b}\times{1}$ column vector containing one multidimensional observation
- $\mathbold{x}$ is an ${n}\times{1}$ column vector of /model states/
- $\mathbold{Z}$ is a  ${b}\times{b}$ matrix, the covariance of
  observation noise
- $\mathbold{P}$ is an ${n}\times{n}$ matrix, the theoretical
  covariance of $\mathbold{x}$
- $\mathbold{A}$ is a  ${b}\times{n}$ matrix, the /observation partials/
- $\mathbold{D}$ is a  ${b}\times{b}$ matrix, the Kalman denominator
- $\mathbold{K}$ is an ${n}\times{b}$ matrix, the Kalman gain

In physical or engineering applications, these quantities carry physical
dimensions of units of measure in addition to their matrix dimensions as numbers
of rows and columns. 
If the physical and matrix dimensions of 
$\mathbold{x}$ 
are
$\left[\left[\mathbold{x}\right]\right]
\stackrel{\text{\tiny def}}{=}
(\mathcal{X}, n\times{1})$
and of 
$\mathbold{z}$ 
are
$\left[\left[\mathbold{z}\right]\right]
\stackrel{\text{\tiny def}}{=}
(\mathcal{Z}, b\times{1})$, then

#+BEGIN_LaTeX
\begin{equation}
\label{eqn:dimensional-breakdown}
\begin{array}{lccccr}
\left[\left[\mathbold{Z}\right]\right]                                       &=& (&\mathcal{Z}^2            & b\times{b}&) \\
\left[\left[\mathbold{A}\right]\right]                                       &=& (&\mathcal{Z}/\mathcal{X}  & b\times{n}&) \\
\left[\left[\mathbold{P}\right]\right]                                       &=& (&\mathcal{X}^2            & n\times{n}&) \\
\left[\left[\mathbold{A}\,\mathbold{P}\,\mathbold{A}^\intercal\right]\right] &=& (&\mathcal{Z}^2            & b\times{b}&) \\
\left[\left[\mathbold{D}\right]\right]                                       &=& (&\mathcal{Z}^2            & b\times{b}&) \\
\left[\left[\mathbold{P}\,\mathbold{A}^\intercal\right]\right]               &=& (&\mathcal{X}\,\mathcal{Z} & n\times{b}&) \\
\left[\left[\mathbold{K}\right]\right]                                       &=& (&\mathcal{X}/\mathcal{Z}  & n\times{b}&)
\end{array}
\end{equation}
#+END_LaTeX

Dimensional arguments, regarding both matrix dimensions and physical dimensions,
are invaluable for checking code and derivations in this topic at-large.

** A Test Example

In the following  example, the observations $\mathbold{z}$ are
$1\times{1}$ matrices, equivalent to scalars, so $b=1$.

The function in equation \ref{eqn:kalman-cume-definition}
/lambda-lifts/[fn:lmlf] $\mathbold{Z}$, meaning that it is necessary to call
/kalmanStatic/ with a constant $\mathbold{Z}$ to get the actual accumulator
function used in folds. This is desirable to reduce coupling between the
accumulator function and its calling environment. 

In Wolfram, this function is

#+BEGIN_LaTeX
\begin{verbatim}
kalmanStatic[Zeta_][{x_, P_}, {A_, z_}] :=
 Module[{D, K},
  D = Zeta + A.P.Transpose[A];
  K = P.Transpose[A].Inverse[D];
  {x2 + K.(z - A.x), P - K.D.Transpose[K]}]
\end{verbatim}
#+END_LaTeX

We test it on a small case

#+BEGIN_LaTeX
\begin{verbatim}
Fold[kalmanStatic[IdentityMatrix[1]],
  {ColumnVector[{0, 0, 0, 0}], IdentityMatrix[4]*1000.0},
  {{{{1,  0., 0.,  0.}}, { -2.28442}}, 
   {{{1,  1., 1.,  1.}}, { -4.83168}}, 
   {{{1, -1., 1., -1.}}, {-10.46010}}, 
   {{{1, -2., 4., -8.}}, {  1.40488}}, 
   {{{1,  2., 4.,  8.}}, {-40.8079}}}
  ] // Chop
~~>
\end{verbatim}
#+END_LaTeX

#+BEGIN_LaTeX
\begin{align}
\label{eqn:kalman-filter-results}
\mathbold{x} &=
\begin{bmatrix}
 -2.97423 \\
  7.2624  \\
 -4.21051 \\
 -4.45378 \\
\end{bmatrix}
\\
\notag
\mathbold{P} &=
\begin{bmatrix}
 0.485458 & 0 & -0.142778 & 0 \\
 0 & 0.901908 & 0 & -0.235882 \\
 -0.142778 & 0 & 0.0714031 & 0 \\
 0 & -0.235882 & 0 & 0.0693839 \\
\end{bmatrix}
\end{align}
#+END_LaTeX

\noindent expecting results within one or two standard deviations of the ground
truth $\aleph=\begin{bmatrix}-3& 9& -4& -5\end{bmatrix}^\intercal$, where the
standard deviations can be found as square roots of the diagonal
elements of $\mathbold{P}$. For details about this test case, see the first
paper in the series, /Kalman Folding, Part 1/.[fn:klfl]

Below, we reproduce these values exactly, to the bit level, by running
/kalmanStatic/ over lazy streams and asynchronous observables.

* COMMENT Concluding Remarks

With prototypes for /foldStream/ and /foldObservable/, we have demonstrated
Kalman folding with exactly the same accumulator function over wildly different
data-delivery environments. This demonstrates the primary thesis of this series
of papers: that writing filters as functional folds enables verbatim deployment
of code in both friendly, synchronous environments with all data in memory, and
unfriendly asynchronous environments using only constant memory. Verbatim means
with no changes at all, not even recompilation. 

We have tested these prototypes against bigger
examples like the tracking example[fn:trak] and the accelerometer
example,[fn:klfl] and there are no surprises.


* Literate Code

** COMMENT Step 1: Getting C to Work

First, make sure the following works[fn:obc1] in org-babel and org-babel tangle. If it
does work, you have a correctly installed C compiler.

#+begin_src C++ :includes '(<stdio.h>) :tangle k-folding.c
  int a=7;
  int b=7;
  printf("%d\n", a*b);
#+end_src

#+RESULTS:
: 49

** Recurrence for the Mean
*** Business Code

C code is usually much longer than the corresponding Wolfram code (or Lisp, or
Haskell, or OCaml, etc.). The extra length, overall, is due mostly to the need
for manual memory management in C. However, we also don't have pattern matching
for unpacking inputs and we don't have literal list / array notation for
expressing some inputs and for packing outputs.

The goal of our C code is to make the final result as clean and as close to the
original design in Wolfram as possible. For instance, the original source for
/Recurrence for the Mean/ in paper 1[fn:klf1] is

#+BEGIN_SRC Mathematica
cume[{x_, n_}, z_] := (* pattern matching for unpacking inputs *)
  With[{K = 1/(n + 1)},
   {x + K (z - x), n + 1}]; (* literal notation for packing outputs *)
Fold[cume, {0, 0}, {55, 89, 144}] (* literal notation for some inputs *)
~~> {96, 3}
#+END_SRC

The equivalent ``business'' code in C is still longer, but can see that the code
for computing the gain and for the resulting /Accumulation/ is virtually
identical (we must use an explicit multiplication operator =*=, whereas a space
suffices in Wolfram for scalar multiplication). At least the memory management
is hidden in the types /Accumulation/ and /Observation/, articulated further
below.

#+NAME: c-business-logic
#+BEGIN_SRC C :results none
  {   Accumulator cume = ^(Accumulation a, Observation z)
          {   /* unpack inputs */
              T x = a.elements[0];
              T n = a.elements[1];
              /* compute gain */
              T K = 1.0 / (1.0 + n);
              /* busines logic, and packing results */
              Accumulation r;
              r.elements[0] = x + K * (z - x);
              r.elements[1] = 1.0 + n;

              return r;   };

      Accumulation x0 = zeroAccumulation ();

      Observation tmp[3] = {55, 89, 144};
      Observations zs = createObservations(3, tmp);

      Accumulation result = fold (cume, x0, zs);

      printAccumulation (result);
      return 0;   }
#+END_SRC

*** Accumulation Type

The code for the Accumulation type is a bit elaborate, but the extra
abstractions will serve us well when we get to the Kalman filter.

The Accumulation structure presumes that all values are copied around on every
use, and that's safe, and also means that we don't need alloc & free routines
for this type. These accumulation types are usually small, so the time needed to
copy them around may be acceptable. More sophisticated memory management for
them entails more code, so we opt for keeping the code small at the cost of some
copying that could be optimized away.

Also, in the interest of saving space, specifically, staircases of closing curly
braces on lines by themselves, we adopt the /Pico/[fn:pico] style for bracing. 

#+NAME: c-accumulation-type
#+BEGIN_SRC C
  typedef double T;

  const size_t Accumulation_size = 2;
  typedef struct s_Accumulation
  {   T elements[Accumulation_size];   } Accumulation;

  Accumulation zeroAccumulation (void)
  {   Accumulation r;
      memset ((void *)r.elements, 0, Accumulation_size * sizeof (T));
      return r;   }

  void printAccumulation (Accumulation a)
  {    printf ("{%lf, %lf}\n", a.elements[0], a.elements[1]);   }
#+END_SRC

*** Observation Type

Here, because we don't statically know the number of observations, we must use
dynamic memory allocation. In an embedded application, we would use arena memory
(fixed-length circular buffer pools of fixed-length structs) or stack allocation
(/calloc/). Here, for brevity and because this is a testing deployment, we use
heap memory (stdlib's /malloc/ and /free/). These are unacceptable in embedded
applications because of fragmentation and unbounded execution times.

When we get to lazy streams, we won't need these at all. They're only for arrays
of observations all in memory at one time.

The primary helper type is a bounded array of /Observations/ type that includes
length information and a handy iterator-like /current/ index. Most of the code
for this type concerns explicit memory management for this helper type.

We also include an /Observation/ type, for asbstraction hygiene. 

#+NAME: c-observation-types
#+BEGIN_SRC C
  typedef T Observation, * pObservation;
  typedef struct s_BoundedArray_Observations
  {   int count;
      int current;
      pObservation observations;   } Observations;

  /*private*/pObservation allocObservationArray (int count_)
  {   /* Don't use malloc & free in embedded apps. Use arena or stack memory. */
      pObservation po = (pObservation) malloc (count_ * sizeof (Observation));
      if (NULL == po)
      {   printf ("Failed to alloc %d observations\n", count_);
          exit (-1);   }
      return po;   }

  Observations createObservations (int count_, pObservation pObservations)
  {   pObservation po = allocObservationArray (count_);
      memcpy ((void *)po, (void *)pObservations, sizeof (Observation) * count_);
      Observations result;
      result.count   = count_;
      result.current = 0;
      result.observations    = po;
      return result;   }

  void freeObservations (Observations o)
  {   /* Don't use malloc & free in embedded apps. Use arena or stack memory. */
      free ((void *)o.observations);   }
#+END_SRC

*** Accumulator Type

Our last type definition is for the /Accumulator/ function. Here we cheat a bit
and use an extension to the C language called /Blocks/,[fn:blck] which
implements full closures. We could explicitly implement enough of closures for
our purposes, but this extension is widely available with clang and llvm on
Apple computers and Linux, and it's too convenient to pass up. With compilers
for bare-metal processors in embedded systems, we might not have it and have to
do more work by hand. With this extension, the /Accumulator/ type, defined with
the hat syntax =^=, behaves just like a function pointer, which would be defined
with the ordinary pointer syntax, =*=.

#+NAME: c-accumulator-type
#+BEGIN_SRC C
typedef Accumulation (^Accumulator) (Accumulation a, Observation b);
#+END_SRC

*** The Fold Over Observations

The final piece is the /fold/ operator. This particular one knows details of the
/Observations/ type, so is specific to it. We have another fold over lazy
streams, articulated below, just as with Wolfram.

#+NAME: c-fold-over-observations
#+BEGIN_SRC C
  Accumulation fold (Accumulator f, Accumulation x0, Observations zs)
  {   for (zs.current = 0; zs.current < zs.count; ++zs.current)
      {   x0 = f (x0, zs.observations[zs.current]);   }
      return x0;   }
#+END_SRC

*** Pulling it All Together

#+BEGIN_SRC C :tangle recurrenceForTheMean.c :noweb tangle
  #include <stdio.h>
  #include <string.h>
  #include <stdlib.h>
  #include <Block.h>
  <<c-accumulation-type>>
  <<c-observation-types>>
  <<c-accumulator-type>>
  <<c-fold-over-observations>>
  int main (int argc, char ** argv)
  <<c-business-logic>>
#+END_SRC

\noindent Tangle this code out to a C file by executing `org-babel-tangle' while
visiting this literate source code in emacs. For those who prefer vim, we may
suggest /Spacemacs/,[fn:spcm] which is a package for emacs with near-perfect vim
emulation. A distribution of emacs for the Mac with adequate org-babel support is maintained
by Vincent Goulet at the University of Laval.[fn:lavl]

Compile and run the code as follows:

#+BEGIN_SRC bash :exports both
gcc -Wall -Werror recurrenceForTheMean.c -o recurrenceForTheMean
./recurrenceForTheMean
#+END_SRC

#+RESULTS:
| {96.000000 | 3.000000} |

\noindent producing results all-but-identical to those from the Wolfram language.

** COMMENT Step 2: Getting BLAS to Work (OPTIONAL)

I am building my software on a Mac. The LINUX builds come up without difficulty
if you have gcc and gfortran installed properly. I don't have anything to say
about Windows. It's too different from LINUX and the Mac for me to bother with
it.

*** Step 2.1: Fortran

Make sure you have gfortran. 

Get BLAS.[fn:blas]

Unpack and go to the directory and just type make. It will probably work on
LINUX and on a Mac. Note the full path name of the library that it creates.  On
my Mac, that path is =~/Documents/BLAS-3.6.0/blas_LINUX.a=.

*** Step 2.2: C

Get CBLAS.[fn:cbls] The README file needs some clarification: where it says
``Legacy BLAS library,'' it means the one you just built with gfortran. The
CBLAS samples link against that fortran library. 

Follow the rest of the instrutions. I built the files with =-O3= and the C files
with =-O3 -DADD_=. I copied =Makefile.LINUX= to =Makefile.MACOSX= and linked
=Makefile.in= to =Makefile.MACOSX=, just the way =README= says to do. I think
it's unnecessary. I could have just used the LINUX makefile, but I was being
extra cautious and following all the directions. I named my CBLAS library
cblas_MACOSX.a.

Now it's time to run the test programs.

#+BEGIN_LaTeX
\begin{verbatim}
$ make
$ cd testing
$ make run
\end{verbatim}
#+END_LaTeX

\noindent Don't try to run the programs from the command line. Some of them will
wait forever for a data file. Also, I had some minor difficulties when building
for the debugger with =-O0 -g= and running under both =gdb= and =lldb=. Because
everything is working with =-O3=, I gave up on the debugger versions. I'm OK
with =printf= debugging, anyway. 

** Step 2: Getting LAPACK to work

Make sure you have =gfortran= installed:

#+BEGIN_SRC bash
gfortran --version
#+END_SRC

#+RESULTS:
| GNU       | Fortran | (Homebrew    | gcc    | 5.3.0)   | 5.3.0       |         |        |          |           |         |      |
| Copyright | (C)     | 2015         | Free   | Software | Foundation, | Inc.    |        |          |           |         |      |
|           |         |              |        |          |             |         |        |          |           |         |      |
| GNU       | Fortran | comes        | with   | NO       | WARRANTY,   | to      | the    | extent   | permitted | by      | law. |
| You       | may     | redistribute | copies | of       | GNU         | Fortran |        |          |           |         |      |
| under     | the     | terms        | of     | the      | GNU         | General | Public | License. |           |         |      |
| For       | more    | information  | about  | these    | matters,    | see     | the    | file     | named     | COPYING |      |
|           |         |              |        |          |             |         |        |          |           |         |      |

Get LAPACK.[fn:lpck]
This builds BLAS as a side effect.

#+BEGIN_SRC bash
pushd ~/Documents/lapack-3.6.0
cmake .
make
make test
#+END_SRC

#+RESULTS:

#+BEGIN_SRC bash :export both
pushd ~/Documents/lapack-3.6.0
make install
#+END_SRC

#+RESULTS:
| ~/Documents/lapack-3.6.0 | ~/Documents/kalman-folding |                                                                 |          |            |
| [                        | 5%]                        | Built                                                           | target   | blas       |
| [                        | 59%]                       | Built                                                           | target   | lapack     |
| [                        | 61%]                       | Built                                                           | target   | tmglib     |
| [                        | 62%]                       | Built                                                           | target   | xlintstzc  |
| [                        | 63%]                       | Built                                                           | target   | xlintstrfz |
| [                        | 69%]                       | Built                                                           | target   | xlintstc   |
| [                        | 75%]                       | Built                                                           | target   | xlintstz   |
| [                        | 76%]                       | Built                                                           | target   | xlintstrfc |
| [                        | 76%]                       | Built                                                           | target   | xlintstrfs |
| [                        | 81%]                       | Built                                                           | target   | xlintstd   |
| [                        | 82%]                       | Built                                                           | target   | xlintstrfd |
| [                        | 82%]                       | Built                                                           | target   | xlintstds  |
| [                        | 87%]                       | Built                                                           | target   | xlintsts   |
| [                        | 90%]                       | Built                                                           | target   | xeigtstc   |
| [                        | 93%]                       | Built                                                           | target   | xeigtstz   |
| [                        | 97%]                       | Built                                                           | target   | xeigtsts   |
| [100%]                   | Built                      | target                                                          | xeigtstd |            |
| Install                  | the                        | project...                                                      |          |            |
| --                       | Install                    | configuration:                                                  |          |            |
| --                       | Installing:                | /usr/local/lib/cmake/lapack-3.6.0/lapack-targets.cmake          |          |            |
| --                       | Installing:                | /usr/local/lib/cmake/lapack-3.6.0/lapack-targets-noconfig.cmake |          |            |
| --                       | Installing:                | /usr/local/lib/pkgconfig/lapack.pc                              |          |            |
| --                       | Installing:                | /usr/local/lib/cmake/lapack-3.6.0/lapack-config.cmake           |          |            |
| --                       | Installing:                | /usr/local/lib/cmake/lapack-3.6.0/lapack-config-version.cmake   |          |            |
| --                       | Installing:                | /usr/local/lib/pkgconfig/blas.pc                                |          |            |
| --                       | Installing:                | /usr/local/lib/libblas.a                                        |          |            |
| --                       | Installing:                | /usr/local/lib/liblapack.a                                      |          |            |
| --                       | Installing:                | /usr/local/lib/libtmglib.a                                      |          |            |

*** Make LAPACKE

This is the C interface to LAPACK.  The following mercilessly hacks around a couple of
problems in the build of =examples=, but it's enough to get the example working.

#+BEGIN_SRC bash
pushd ~/Documents/lapack-3.6.0
cp make.inc.example make.inc
cd LAPACKE
make lapacke
#+END_SRC

#+RESULTS:

#+BEGIN_SRC bash :export both
pushd ~/Documents/lapack-3.6.0
find . -name "*.a"
#+END_SRC

#+RESULTS:
| ~/Documents/lapack-3.6.0 | ~/Documents/kalman-folding |
| ./lib/libblas.a          |                            |
| ./lib/liblapack.a        |                            |
| ./lib/libtmglib.a        |                            |
| ./liblapacke.a           |                            |

#+BEGIN_SRC bash :export both
pushd ~/Documents/lapack-3.6.0
cd LAPACKE
cp ./include/lapacke*.h /usr/local/include
cd example
cp ../../liblapacke.a /usr/local/lib
cp ../../lib/*.a ../..
cp ../../libblas.a ../../librefblas.a
make
#+END_SRC

#+RESULTS:
|  ~/Documents/lapack-3.6.0 | ~/Documents/kalman-folding |                       |                    |         |                         |
|                  gfortran |   example_DGESV_rowmajor.o | lapacke_example_aux.o |                  \ |         |                         |
|                           |         ../../liblapacke.a |     ../../liblapack.a | ../../librefblas.a |      -o | xexample_DGESV_rowmajor |
| ./xexample_DGESV_rowmajor |                            |                       |                    |         |                         |
|                           |                            |                       |                    |         |                         |
|                     Entry |                     Matrix |                     A |                    |         |                         |
|                      -0.5 |                      -0.37 |                  0.26 |              -0.04 |    0.03 |                         |
|                     -0.28 |                      -0.45 |                  0.18 |               0.18 |    0.43 |                         |
|                     -0.12 |                       0.02 |                  0.33 |              -0.47 |   -0.45 |                         |
|                      0.03 |                       0.17 |                 -0.49 |              -0.12 |   -0.43 |                         |
|                     -0.08 |                       0.19 |                  0.09 |               0.43 |    0.35 |                         |
|                           |                            |                       |                    |         |                         |
|                     Right |                       Rand |                  Side |                  b |         |                         |
|                      0.03 |                            |                       |                    |         |                         |
|                     -0.41 |                            |                       |                    |         |                         |
|                      0.15 |                            |                       |                    |         |                         |
|                     -0.08 |                            |                       |                    |         |                         |
|                       0.2 |                            |                       |                    |         |                         |
|                           |                            |                       |                    |         |                         |
|             LAPACKE_dgesv |                (row-major, |           high-level) |            Example | Program | Results                 |
|                           |                            |                       |                    |         |                         |
|                  Solution |                            |                       |                    |         |                         |
|                      7.74 |                            |                       |                    |         |                         |
|                     -9.08 |                            |                       |                    |         |                         |
|                      6.77 |                            |                       |                    |         |                         |
|                     16.57 |                            |                       |                    |         |                         |
|                    -15.01 |                            |                       |                    |         |                         |
|                           |                            |                       |                    |         |                         |
|                   Details |                         of |                    LU |      factorization |         |                         |
|                      -0.5 |                      -0.37 |                  0.26 |              -0.04 |    0.03 |                         |
|                      0.17 |                       0.25 |                  0.05 |               0.44 |    0.34 |                         |
|                     -0.06 |                        0.6 |                 -0.51 |              -0.38 |   -0.64 |                         |
|                      0.23 |                       0.43 |                  -0.5 |              -0.83 |   -0.92 |                         |
|                      0.56 |                      -0.99 |                 -0.16 |              -0.69 |    0.02 |                         |
|                           |                            |                       |                    |         |                         |
|                     Pivot |                    indices |                       |                    |         |                         |
|                         1 |                          5 |                     4 |                  4 |       5 |                         |
|                  gfortran |   example_DGESV_colmajor.o | lapacke_example_aux.o |                  \ |         |                         |
|                           |         ../../liblapacke.a |     ../../liblapack.a | ../../librefblas.a |      -o | xexample_DGESV_colmajor |
| ./xexample_DGESV_colmajor |                            |                       |                    |         |                         |
|                           |                            |                       |                    |         |                         |
|                     Entry |                     Matrix |                     A |                    |         |                         |
|                      -0.5 |                      -0.37 |                  0.26 |              -0.04 |    0.03 |                         |
|                     -0.28 |                      -0.45 |                  0.18 |               0.18 |    0.43 |                         |
|                     -0.12 |                       0.02 |                  0.33 |              -0.47 |   -0.45 |                         |
|                      0.03 |                       0.17 |                 -0.49 |              -0.12 |   -0.43 |                         |
|                     -0.08 |                       0.19 |                  0.09 |               0.43 |    0.35 |                         |
|                           |                            |                       |                    |         |                         |
|                     Right |                       Rand |                  Side |                  b |         |                         |
|                      0.03 |                            |                       |                    |         |                         |
|                     -0.41 |                            |                       |                    |         |                         |
|                      0.15 |                            |                       |                    |         |                         |
|                     -0.08 |                            |                       |                    |         |                         |
|                       0.2 |                            |                       |                    |         |                         |
|                           |                            |                       |                    |         |                         |
|             LAPACKE_dgesv |                (row-major, |           high-level) |            Example | Program | Results                 |
|                           |                            |                       |                    |         |                         |
|                  Solution |                            |                       |                    |         |                         |
|                      7.74 |                            |                       |                    |         |                         |
|                     -9.08 |                            |                       |                    |         |                         |
|                      6.77 |                            |                       |                    |         |                         |
|                     16.57 |                            |                       |                    |         |                         |
|                    -15.01 |                            |                       |                    |         |                         |
|                           |                            |                       |                    |         |                         |
|                   Details |                         of |                    LU |      factorization |         |                         |
|                      -0.5 |                      -0.37 |                  0.26 |              -0.04 |    0.03 |                         |
|                      0.17 |                       0.25 |                  0.05 |               0.44 |    0.34 |                         |
|                     -0.06 |                        0.6 |                 -0.51 |              -0.38 |   -0.64 |                         |
|                      0.23 |                       0.43 |                  -0.5 |              -0.83 |   -0.92 |                         |
|                      0.56 |                      -0.99 |                 -0.16 |              -0.69 |    0.02 |                         |
|                           |                            |                       |                    |         |                         |
|                     Pivot |                    indices |                       |                    |         |                         |
|                         1 |                          5 |                     4 |                  4 |       5 |                         |
|                  gfortran |   example_DGELS_rowmajor.o | lapacke_example_aux.o |                  \ |         |                         |
|                           |         ../../liblapacke.a |     ../../liblapack.a | ../../librefblas.a |      -o | xexample_DGELS_rowmajor |
| ./xexample_DGELS_rowmajor |                            |                       |                    |         |                         |
|                           |                            |                       |                    |         |                         |
|                     Entry |                     Matrix |                     A |                    |         |                         |
|                       1.0 |                        1.0 |                   1.0 |                    |         |                         |
|                       2.0 |                        3.0 |                   4.0 |                    |         |                         |
|                       3.0 |                        5.0 |                   2.0 |                    |         |                         |
|                       4.0 |                        2.0 |                   5.0 |                    |         |                         |
|                       5.0 |                        4.0 |                   3.0 |                    |         |                         |
|                           |                            |                       |                    |         |                         |
|                     Right |                       Hand |                  Side |                  b |         |                         |
|                     -10.0 |                       -3.0 |                       |                    |         |                         |
|                      12.0 |                       14.0 |                       |                    |         |                         |
|                      14.0 |                       12.0 |                       |                    |         |                         |
|                           |                            |                       |                    |         |                         |
|             LAPACKE_dgels |                (row-major, |           high-level) |            Example | Program | Results                 |
|                           |                            |                       |                    |         |                         |
|                  Solution |                            |                       |                    |         |                         |
|                       2.0 |                        1.0 |                       |                    |         |                         |
|                       1.0 |                        1.0 |                       |                    |         |                         |
|                       1.0 |                        2.0 |                       |                    |         |                         |
|                           |                            |                       |                    |         |                         |
|                  gfortran |   example_DGELS_colmajor.o | lapacke_example_aux.o |                  \ |         |                         |
|                           |         ../../liblapacke.a |     ../../liblapack.a | ../../librefblas.a |      -o | xexample_DGELS_colmajor |
| ./xexample_DGELS_colmajor |                            |                       |                    |         |                         |
|                           |                            |                       |                    |         |                         |
|                     Entry |                     Matrix |                     A |                    |         |                         |
|                       1.0 |                        1.0 |                   1.0 |                    |         |                         |
|                       2.0 |                        3.0 |                   4.0 |                    |         |                         |
|                       3.0 |                        5.0 |                   2.0 |                    |         |                         |
|                       4.0 |                        2.0 |                   5.0 |                    |         |                         |
|                       5.0 |                        4.0 |                   3.0 |                    |         |                         |
|                           |                            |                       |                    |         |                         |
|                     Right |                       Hand |                  Side |                  b |         |                         |
|                     -10.0 |                       -3.0 |                       |                    |         |                         |
|                      12.0 |                       14.0 |                       |                    |         |                         |
|                      14.0 |                       12.0 |                       |                    |         |                         |
|                           |                            |                       |                    |         |                         |
|             LAPACKE_dgels |                (col-major, |           high-level) |            Example | Program | Results                 |
|                           |                            |                       |                    |         |                         |
|                  Solution |                            |                       |                    |         |                         |
|                       2.0 |                        1.0 |                       |                    |         |                         |
|                       1.0 |                        1.0 |                       |                    |         |                         |
|                       1.0 |                        2.0 |                       |                    |         |                         |
|                           |                            |                       |                    |         |                         |



* Footnotes

[fn:affn] https://en.wikipedia.org/wiki/Affine_transformation
[fn:bars] Bar-Shalom, Yaakov, /et al/. Estimation with applications to tracking and navigation. New York: Wiley, 2001.
[fn:bier] http://tinyurl.com/h3jh4kt
[fn:blck] http://tinyurl.com/bgwfkyc
[fn:bssl] https://en.wikipedia.org/wiki/Bessel's_correction
[fn:blas] http://www.netlib.org/blas/
[fn:busi] https://en.wikipedia.org/wiki/Business_logic
[fn:cbls] http://www.netlib.org/blas/
[fn:cdot] We sometimes use the center dot or the $\times$ symbols to clarify
matrix multiplication. They have no other significance and we can always write
matrix multiplication just by juxtaposing the matrices.
[fn:clos] https://en.wikipedia.org/wiki/Closure_(computer_programming)
[fn:cold] This convention only models so-called /cold observables/, but it's enough to demonstrate Kalman's working over them.
[fn:cons] This is quite similar to the standard --- not  Wolfram's --- definition of a list as a pair of a value and of another list.
[fn:cova] We use the terms /covariance/ for matrices and /variance/ for scalars.
[fn:csoc] https://en.wikipedia.org/wiki/Separation_of_concerns
[fn:ctsc] https://en.wikipedia.org/wiki/Catastrophic_cancellation
[fn:dstr] http://tinyurl.com/ze6qfb3
[fn:elib] Brookner, Eli. Tracking and Kalman Filtering Made Easy, New York: Wiley, 1998. http://tinyurl.com/h8see8k
[fn:fldl] http://tinyurl.com/jmxsevr
[fn:fwik] https://en.wikipedia.org/wiki/Fold_%28higher-order_function%29
[fn:gama] https://en.wikipedia.org/wiki/Gauss%E2%80%93Markov_theorem
[fn:intr] http://introtorx.com/
[fn:jplg] JPL Geodynamics Program http://www.jpl.nasa.gov/report/1981.pdf
[fn:just] justified by the fact that $\mathbold{D}$ is a diagonal
matrix that commutes with all other products, therefore its left and right
inverses are equal and can be written as a reciprocal; in fact, $\mathbold{D}$
is a $1\times{1}$ matrix --- effectively a scalar --- in all examples in this paper
[fn:klde] B. Beckman, /Kalman Folding 3: Derivations/, to appear.
[fn:klf1] B. Beckman, /Kalman Folding, Part 1/, to appear.
[fn:klf2] B. Beckman, /Kalman Folding 2: Tracking and System Dynamics/, to appear.
[fn:klf3] B. Beckman, /Kalman Folding 3: Derivations/, to appear.
[fn:klf4] B. Beckman, /Kalman Folding 4: Streams and Observables/, to appear.
[fn:klf5] B. Beckman, /Kalman Folding 5: Non-Linear Models and the EKF/, to appear.
[fn:klf7] B. Beckman, /Kalman Folding 7: A Small Streams Library/, to appear.
[fn:klf9] B. Beckman, /Kalman Folding 9: in C/, to appear.
[fn:klfl] B. Beckman, /Kalman Folding, Part 1/, to appear.
[fn:lavl] http://vgoulet.act.ulaval.ca/en/emacs/
[fn:layi] https://en.wikipedia.org/wiki/Fundamental_theorem_of_software_engineering
[fn:lmbd] Many languages use the keyword /lambda/ for such expressions; Wolfram
uses the name /Function/.
[fn:lmlf] https://en.wikipedia.org/wiki/Lambda_lifting
[fn:lpck] http://www.netlib.org/lapack/
[fn:lsqo] LINQ's Standard Query Operators
[fn:lssq] https://en.wikipedia.org/wiki/Least_squares
[fn:ltis] http://tinyurl.com/hhhcgca
[fn:matt] https://www.cs.kent.ac.uk/people/staff/dat/miranda/whyfp90.pdf
[fn:mcmc] https://en.wikipedia.org/wiki/Particle_filter
[fn:mond] https://en.wikipedia.org/wiki/Monad
[fn:musc] http://www1.cs.dartmouth.edu/~doug/music.ps.gz
[fn:ndim] https://en.wikipedia.org/wiki/Nondimensionalization
[fn:obc1] Make sure the first example from http://tinyurl.com/kz2lz7m works
[fn:patt] http://tinyurl.com/j5jzy69
[fn:pico] http://tinyurl.com/gku2k74
[fn:pseu] http://tinyurl.com/j8gvlug
[fn:rasp] http://www.wolfram.com/raspberry-pi/
[fn:rcrn] https://en.wikipedia.org/wiki/Recurrence_relation
[fn:rsfr] http://rosettacode.org/wiki/Loops/Foreach
[fn:rxbk] http://www.introtorx.com/content/v1.0.10621.0/07_Aggregation.html
[fn:scan] and of Haskell's scans and folds, and Rx's scans and folds, /etc./
[fn:scla] http://tinyurl.com/hhdot36
[fn:scnd] A state-space form containing a position and derivative is commonplace
in second-order dynamics like Newton's Second Law. We usually employ state-space
form to reduce \(n\)-th-order differential equations to first-order differential
equations by stacking the dependent variable on $n-1$ of its derivatives in the
state vector.
[fn:scnl] http://learnyouahaskell.com/higher-order-functions
[fn:spcm] http://www.spacemacs.org
[fn:stsp] https://en.wikipedia.org/wiki/State-space_representation
[fn:trak] B. Beckman, /Kalman Folding 2: Tracking and System Dynamics/, To appear.
[fn:uncl] The initial uncial (lower-case) letter signifies that /we/ wrote this function; it wasn't supplied by Wolfram.
[fn:wfld] http://reference.wolfram.com/language/ref/FoldList.html?q=FoldList
[fn:wlf1] http://tinyurl.com/nfz9fyo
[fn:wlf2] http://rebcabin.github.io/blog/2013/02/04/welfords-better-formula/
[fn:wolf] http://reference.wolfram.com/language/
[fn:zarc] Zarchan and Musoff, /Fundamentals of Kalman Filtering, A Practical
Approach, Fourth Edition/, Ch. 4

